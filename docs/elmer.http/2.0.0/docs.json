[{"name":"Elmer.Http","comment":" Functions for handling Http requests in your tests.\n\nYour component makes Http requests. You want to describe the behavior of your\ncomponent. What to do?\n\n1. Create an HttpResponseStub -- see `Elmer.Http.Stub`\n\n2. Serve it up during your test\n\n3. Smile!\n\n# Serve Stubbed Responses\n@docs HttpResponseStub, serve\n\n# Make Expectations about Http Requests\n@docs expectRequest, expect, clearRequestHistory\n\n","unions":[],"aliases":[{"name":"HttpResponseStub","comment":" Represents a stubbed HttpResponse\n\nUse `Elmer.Http.Stub` to build an `HttpResponseStub`.\n","args":[],"type":"Elmer.Http.Types.HttpResponseStub Http.Error"}],"values":[{"name":"clearRequestHistory","comment":" Clear any Http requests that may have been recorded at an earlier point\nin the history of this TestState.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"expect","comment":" Make some expectation about requests to the specified route.\n\n    expect (Elmer.Http.Route.get \"http://fun.com/fun\") (\n      Elmer.each <| \n        Elmer.Http.Matchers.hasHeader \n          (\"X-Auth-Token\", \"MY-TOKEN\")\n    )\n\nIf no requests have been made to the specified route, an empty list\nwill be passed to the `Matcher (List HttpRequest)`.\n\nNote: This must be used in conjunction with `Elmer.Http.serve` or `Elmer.Http.spy`.\n","type":"Elmer.Http.Route.HttpRoute -> Elmer.Matcher (List.List Elmer.Http.Request.HttpRequest) -> Elmer.Matcher (Elmer.TestState model msg)"},{"name":"expectRequest","comment":" Expect one or more requests to the specified route.\n\nIf no requests have been made to the specified route, the test will fail.\n\nNote: This must be used in conjunction with `Elmer.Http.serve` or `Elmer.Http.spy`.\n","type":"Elmer.Http.Route.HttpRoute -> Elmer.Matcher (Elmer.TestState model msg)"},{"name":"serve","comment":" Override `Http.send` and `Http.toTask` to register HttpResponseStubs that will be\nreturned when the appropriate request is received. Used in conjunction with\n`Elmer.Spy.use`.\n\nSuppose you have a component that requests information about a user when\na button is clicked. You could register a stub for that request like so\n\n    let\n      stubbedResponse = \n        Elmer.Http.Stub.for (\n          Elmer.Http.Route.post \"http://fun.com/user\"\n        ) \n          |> Elmer.Http.Stub.withBody\n            \"{\\\"name\\\":\\\"Super User\\\"}\"\n    in\n      testState\n        |> Spy.use [ serve [ stubbedResponse ] ]\n        |> Markup.target\n            << by [ id \"submit-button\" ]\n        |> Elmer.Html.Event.click\n        |> Markup.target\n            << by [ id \"result\" ]\n        |> Markup.expect (Matchers.element <| \n            Matchers.hasText \"Hello, Super User!\"\n          )\n\n","type":"List.List Elmer.Http.HttpResponseStub -> Elmer.Spy.Spy"}],"binops":[]},{"name":"Elmer.Http.Matchers","comment":" Make expectations about Http requests sent by the component under test.\n\nThese matchers should be used with `Elmer.Http.expect`.\n\nNote: Your test must use `Elmer.Http.serve` or `Elmer.Http.spy` at the\nappropriate time to allow Elmer to record the requests sent by the component\nunder test.\n\n# Matchers\n@docs wasRequested, hasBody, hasQueryParam, hasHeader\n","unions":[],"aliases":[],"values":[{"name":"hasBody","comment":" Match a request with the specified body.\n\n    Elmer.Http.expect (Elmer.Http.Route.post \"http://fake.com/fake\") (\n      Elmer.some <| \n        hasBody \"{\\\"name\\\":\\\"Fun Person\\\"}\"\n    )\n\n","type":"String.String -> Elmer.Matcher Elmer.Http.Request.HttpRequest"},{"name":"hasHeader","comment":" Match a request with the specified header name and value.\n\n    Elmer.Http.expect (Elmer.Http.Route.get \"http://fake.com/fake\") (\n      Elmer.some <| \n        hasHeader ( \"x-auth-token\", \"xxxxx\" )\n    )\n\n","type":"( String.String, String.String ) -> Elmer.Matcher Elmer.Http.Request.HttpRequest"},{"name":"hasQueryParam","comment":" Match a request that has a query string containing the specified name and value.\n\nNote: You don't need to worry about url encoding the name or value.\n\n    Elmer.Http.expect (Elmer.Http.Route.get \"http://fake.com/fake\") (\n      Elmer.some <| \n        hasQueryParam ( \"name\", \"Fun Person\" )\n    )\n\n","type":"( String.String, String.String ) -> Elmer.Matcher Elmer.Http.Request.HttpRequest"},{"name":"wasRequested","comment":" Expect that exactly some number of requests have been recorded.\n\n    Elmer.Http.expect (Elmer.Http.Route.get \"http://fun.com/fun.html\") (\n      wasRequested 3\n    )\n","type":"Basics.Int -> Elmer.Matcher (List.List Elmer.Http.Request.HttpRequest)"}],"binops":[]},{"name":"Elmer.Http.Request","comment":" Functions for working with a recorded HTTP request.\n\n@docs HttpRequest, body, queryString, headers\n\n","unions":[],"aliases":[{"name":"HttpRequest","comment":" Represents a recorded HTTP request about which expectations may be made.\n","args":[],"type":"Elmer.Http.Types.HttpRequest"}],"values":[{"name":"body","comment":" Get the body of a recorded HTTP request.\n","type":"Elmer.Http.Request.HttpRequest -> Maybe.Maybe String.String"},{"name":"headers","comment":" Get the headers of a recorded HTTP request as a list of (name, value) tuples. \n","type":"Elmer.Http.Request.HttpRequest -> List.List ( String.String, String.String )"},{"name":"queryString","comment":" Get the query string of a recorded HTTP request, if it exists\n","type":"Elmer.Http.Request.HttpRequest -> Maybe.Maybe String.String"}],"binops":[]},{"name":"Elmer.Http.Result","comment":" Functions for working with the stubbed result of an HTTP request.\n\n@docs HttpResult, withBody, withHeader, withStatus\n\n","unions":[],"aliases":[{"name":"HttpResult","comment":" Represents the stubbed result of an HTTP request.\n","args":[],"type":"Elmer.Http.Types.HttpResult Http.Error"}],"values":[{"name":"withBody","comment":" Set the body of an HttpResult.\n\nIf the given HttpResult is set to return an error, then this function\nwill do nothing. \n","type":"String.String -> Elmer.Http.Result.HttpResult -> Elmer.Http.Result.HttpResult"},{"name":"withHeader","comment":" Add a header to an HttpResult.\n\nIf the given HttpResult is set to return an error, then this function\nwill do nothing. \n","type":"( String.String, String.String ) -> Elmer.Http.Result.HttpResult -> Elmer.Http.Result.HttpResult"},{"name":"withStatus","comment":" Set the status of an HttpResult.\n\nIf the given HttpResult is set to return an error, then this function\nwill do nothing.\n","type":"Elmer.Http.Status.HttpStatus -> Elmer.Http.Result.HttpResult -> Elmer.Http.Result.HttpResult"}],"binops":[]},{"name":"Elmer.Http.Route","comment":" Functions for working with HTTP routes.\n\nA route is an HTTP request method plus a URL, up to but not including a query string.\n\n# Creating an HttpRoute\n@docs HttpRoute, get, post, delete, put, patch\n\n# Accessing an HttpRoute\n@docs method, url\n\n","unions":[],"aliases":[{"name":"HttpRoute","comment":" Represents an HTTP route, which is a URL plus an HTTP request method.\n","args":[],"type":"Elmer.Http.Types.HttpRoute"}],"values":[{"name":"delete","comment":" Create a route for an HTTP DELETE.\n\n    delete \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n","type":"String.String -> Elmer.Http.Route.HttpRoute"},{"name":"get","comment":" Create a route for an HTTP GET.\n\n    get \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n","type":"String.String -> Elmer.Http.Route.HttpRoute"},{"name":"method","comment":" Return the route's method.\n","type":"Elmer.Http.Route.HttpRoute -> String.String"},{"name":"patch","comment":" Create a route for an HTTP PATCH.\n\n    patch \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n","type":"String.String -> Elmer.Http.Route.HttpRoute"},{"name":"post","comment":" Create a route for an HTTP POST.\n\n    post \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n","type":"String.String -> Elmer.Http.Route.HttpRoute"},{"name":"put","comment":" Create a route for an HTTP PUT.\n\n    put \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n","type":"String.String -> Elmer.Http.Route.HttpRoute"},{"name":"url","comment":" Return the route's url.\n","type":"Elmer.Http.Route.HttpRoute -> String.String"}],"binops":[]},{"name":"Elmer.Http.Status","comment":" Functions for working with Http status codes.\n\n# General\n@docs HttpStatus, httpStatus\n\n# Common Status Codes\n@docs ok, created, unauthorized, forbidden, notFound, serverError\n\n","unions":[],"aliases":[{"name":"HttpStatus","comment":" Represents the status of an Http response\n","args":[],"type":"Elmer.Http.Types.HttpStatus"}],"values":[{"name":"created","comment":" The `201 Created` Http status.\n","type":"Elmer.Http.Status.HttpStatus"},{"name":"forbidden","comment":" The `403 Forbidden` Http status.\n","type":"Elmer.Http.Status.HttpStatus"},{"name":"httpStatus","comment":" Generate an `HttpStatus`.\n","type":"Basics.Int -> String.String -> Elmer.Http.Status.HttpStatus"},{"name":"notFound","comment":" The `404 Not Found` Http status.\n","type":"Elmer.Http.Status.HttpStatus"},{"name":"ok","comment":" The `200 OK` Http status.\n","type":"Elmer.Http.Status.HttpStatus"},{"name":"serverError","comment":" The `500 Internal Server Error` Http status.\n","type":"Elmer.Http.Status.HttpStatus"},{"name":"unauthorized","comment":" The `401 Unauthorized` Http status.\n","type":"Elmer.Http.Status.HttpStatus"}],"binops":[]},{"name":"Elmer.Http.Stub","comment":" Functions for building stubbed responses to Http requests.\n\n# Create a stubbed response\n@docs for\n\n# Describe the Response\n@docs withBody, withHeader, withStatus, withError\n\n# Provide a Result based on the Request\n@docs withResult\n\n# Defer the Response\n@docs deferResponse\n\n","unions":[],"aliases":[],"values":[{"name":"deferResponse","comment":" Defer a response.\n\nThe response will not be processed until `Elmer.Command.resolveDeferred` is called.\n\nNote: If this stub is processed as part of a request made with `Http.toTask` then the\nentire Task chain will be deferred until `Elmer.Command.resolveDeferred` is called.\n\n","type":"Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"},{"name":"for","comment":" Stub the response for a request to the specified route.\n\nBy default, this response will return an empty body with a status of\n`200 OK`.\n","type":"Elmer.Http.Route.HttpRoute -> Elmer.Http.HttpResponseStub"},{"name":"withBody","comment":" Build a response stub that returns the specified string as its body.\n\nSuppose you want to describe the behavior that results when a response body is\nparsed. You could create a stub like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.post \"http://fake.com/fake\")\n      |> withBody \"{\\\"name\\\":\\\"Fun Person\\\"}\"\n\n","type":"String.String -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"},{"name":"withError","comment":" Build a response stub that results in an `Http.Error`.\n\nSuppose you want to describe the behavior that should result when a request\ntimes out. You could create a stubbed response like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.get \"http://fake.com/fake\")\n      |> withError Http.Error.Timout\n\nNote: If you want to stub a BadStatus or BadBody error, then you should use\nElmer.Http.Stub.withStatus or Elmer.Http.Stub.withBody, respectively.\n\n","type":"Http.Error -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"},{"name":"withHeader","comment":" Build a response stub that has the specified header.\n\nAdd as many headers as necessary like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.post \"http://fake.com/fake\")\n      |> withBody \"{\\\"name\\\":\\\"Fun Person\\\"}\"\n      |> withHeader (\"x-fun-header\", \"something fun\")\n      |> withHeader (\"x-awesome-header\", \"something awesome\")\n","type":"( String.String, String.String ) -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"},{"name":"withResult","comment":" Build a response stub that generates an HttpResult based on the matching\nHttpRequest.\n\nYou could create a stub that returns a body only given a certain query string like so:\n\n    Elmer.Http.Stub.for (\n        Elmer.Http.Route.post \"http://fake.com/fake\"\n    )\n      |> withResult (\\request ->\n        let\n          hasBowling =\n            Elmer.Http.Request.queryString request\n              |> String.contains \"sport=bowling\"\n        in\n          if hasBowling then\n            Elmer.Http.Result.withBody\n              \"{\\\"sport\\\":\\\"bowling\\\"}\"\n          else\n            Elmer.Http.Result.withStatus\n              Elmer.Http.Status.notFound\n      )\n","type":"(Elmer.Http.Request.HttpRequest -> Elmer.Http.Result.HttpResult -> Elmer.Http.Result.HttpResult) -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"},{"name":"withStatus","comment":" Build a response stub that returns some particular status.\n\nSuppose you want to describe the behavior that should result when a request\nreturns a `500 Internal Server Error`. You could create a stubbed response like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.get \"http://fake.com/fake\")\n      |> withStatus \n          Elmer.Http.Status.serverError\n\n","type":"Elmer.Http.Status.HttpStatus -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"}],"binops":[]}]