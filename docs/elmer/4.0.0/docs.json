[
  {
    "name": "Elmer",
    "comment": " Basic types and functions for working with tests and matchers.\n\n@docs TestState\n\n# Working with Matchers\n@docs Matcher, expectAll, expectNot\n\n# List Matchers\n@docs each, exactly, some, atIndex, last, hasLength\n\n# Make low-level expectations\n@docs given, expectModel\n\n",
    "unions": [],
    "aliases": [
      {
        "name": "Matcher",
        "comment": " Generic type for functions that pass or fail.\n\nA matcher returns an `Expect.Expectation` from the\n[elm-test](https://package.elm-lang.org/packages/elm-explorations/test/latest)\npackage.\n",
        "args": [
          "a"
        ],
        "type": "a -> Expect.Expectation"
      },
      {
        "name": "TestState",
        "comment": " Represents the current state of the test.\n",
        "args": [
          "model",
          "msg"
        ],
        "type": "Elmer.TestState.TestState model msg"
      }
    ],
    "values": [
      {
        "name": "atIndex",
        "comment": " Expect that the item at the given index satisfies the given matcher.\n",
        "type": "Basics.Int -> Elmer.Matcher a -> Elmer.Matcher (List.List a)"
      },
      {
        "name": "each",
        "comment": " Expect that all items in a list satisfy the given matcher.\n",
        "type": "Elmer.Matcher a -> Elmer.Matcher (List.List a)"
      },
      {
        "name": "exactly",
        "comment": " Expect that exactly some number of items in a list satisfy the given matcher.\n",
        "type": "Basics.Int -> Elmer.Matcher a -> Elmer.Matcher (List.List a)"
      },
      {
        "name": "expectAll",
        "comment": " Expect that all matchers pass.\nIf one fails, then the conjoined matcher fails, otherwise it passes.\n\n    Elmer.given someModel view update\n      |> Elmer.Html.expect (\n        Elmer.Html.Matchers.element <|\n          Elmer.Html.expectAll\n            [ Elmer.Html.Matchers.hasText \"Awesome\"\n            , Elmer.Html.Matchers.hasClass \"cool\"\n            ]\n        )\n",
        "type": "List.List (Elmer.Matcher a) -> Elmer.Matcher a"
      },
      {
        "name": "expectModel",
        "comment": " Make expectations about the model in its current state.\n\n    Elmer.given defaultModel view update\n      |> Elmer.Html.target \"button\"\n      |> Elmer.Html.Event.click\n      |> Elmer.expectModel (\\model ->\n        Expect.equal model.clickCount 1\n      )\n\nUse Elmer to get the model into a certain state. Then use the normal facilities of\nelm-test to describe how the model should look in that state.\n",
        "type": "Elmer.Matcher model -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "expectNot",
        "comment": " Expect that a matcher fails.\n",
        "type": "Elmer.Matcher a -> Elmer.Matcher a"
      },
      {
        "name": "given",
        "comment": " Initialize a test with a model, view function, and update function.\n",
        "type": "model -> (model -> Html.Html msg) -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"
      },
      {
        "name": "hasLength",
        "comment": " Expect that a list has the given length.\n",
        "type": "Basics.Int -> Elmer.Matcher (List.List a)"
      },
      {
        "name": "last",
        "comment": " Expect that the last item in a list satisfies the given matcher.\n",
        "type": "Elmer.Matcher a -> Elmer.Matcher (List.List a)"
      },
      {
        "name": "some",
        "comment": " Expect that at least one item in a list satisfies the given matcher.\n",
        "type": "Elmer.Matcher a -> Elmer.Matcher (List.List a)"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Command",
    "comment": " Functions for dealing with commands during your tests.\n\nElmer allows you to manage the effects of commands yourself, so you can\ndescribe the behavior of a component under whatever conditions you need.\n\nTo manage the effects of a command, you'll need to do two things.\n\n1. Stub the function in your code that produces the command and replace\nit with a function that returns one of the fake commands described below.\n\n2. Enjoy.\n\nNote: Elmer supports `Platform.Cmd.batch` and `Platform.Cmd.map` so you can use these in your\ncomponent as expected.\n\nNote: Elmer provides special support for commands generated by\n[elm/http](http://package.elm-lang.org/packages/elm/http/latest)\nand [elm/browser](https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation)\n-- See `Elmer.Http` and `Elmer.Navigation`, respectively.\n\n# Fake Commands\n@docs fake, dummy, expectDummy, fail\n\n# Defer a Command\n@docs defer, resolveDeferred\n\n# Send a Fake Command\n@docs send\n\n# Test a Command\n@docs given, expectMessages\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "defer",
        "comment": " Defer a command for later processing.\n\nYou might want to describe the behavior that occurs after a command\nis sent but before its effect is processed -- for example, the component could\nindicate that network activity is occurring while waiting for a request to complete.\n\nWhen a deferred command is processed, any effect associated with that command will *not* be sent\nto the component's `update` function until `resolveDeferred` is called.\n",
        "type": "Platform.Cmd.Cmd msg -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "dummy",
        "comment": " Generate a dummy command.\n\nYou might only care to describe the fact that a command has been sent, and not\nthe behavior that may result from its effect. In that case, use a dummy command.\n\nWhen this command is processed, the fact that it occured will be\nrecorded; no message will be passed to the component's `update` function.\nThis will be most useful in conjunction with `expectDummy`.\n",
        "type": "String.String -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "expectDummy",
        "comment": " Expect that a dummy command with the given identifier has been sent.\n",
        "type": "String.String -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "expectMessages",
        "comment": " Make expectations about messages generated by processing a command.\n\n    Elmer.Command.given (\\() -> \n        MyModule.commandToSendAnHttpRequest someArg\n    )\n      |> Elmer.Spy.use \n          [ Elmer.Http.serve [ someStubbedResponse ] ]\n      |> Elmer.expectMessages (\n        exactly 1 <| Expect.equal (\n          MyMessage <| \n            Ok \"response from server\"\n        )\n      )\n\nNote that `expectMessages` should only be used in a test initialized\nwith `Elmer.Command.given`.\n",
        "type": "Elmer.Matcher (List.List msg) -> Elmer.Matcher (Elmer.TestState.TestState () msg)"
      },
      {
        "name": "fail",
        "comment": " Generate a command that will cause the test to fail with the specified message.\n",
        "type": "String.String -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "fake",
        "comment": " Generate a command that returns a message.\n\nWhen this command is processed, the message will be passed\nto the component's `update` function.\n",
        "type": "msg -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "given",
        "comment": " Initialize a `TestState` with a command.\n\nA test initialized in this way can use `expectMessages` to examine\nmessages generated when the given command is processed.\n",
        "type": "(() -> Platform.Cmd.Cmd msg) -> Elmer.TestState.TestState () msg"
      },
      {
        "name": "resolveDeferred",
        "comment": " Resolve any deferred commands.\n\nOnce this function is called, all messages associated with deferred commands will be\nsent to the component's `update` function.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "send",
        "comment": " Send a command.\n\nUse this function to send a command to your program. Any effect associated with this\ncommand will be processed accordingly. Elmer only knows how to process the fake commands\ndescribed above.\n\nThe first argument is a function that returns the command to be sent.\nWe do this to allow Elmer to evaluate the command-generating function lazily,\nin case any stubbed functions need to be applied.\n\n    testState\n      |> send (\\() -> \n          MyModule.generateSomeCommand\n        )\n      |> Elmer.Html.target \n          << by [ class \"some-class\" ]\n      |> Elmer.Html.expect \n          Elmer.Html.Matchers.elementExists\n\n",
        "type": "(() -> Platform.Cmd.Cmd msg) -> Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Html",
    "comment": " Functions for working with the `Html msg` generated by the component's view function.\n\n# Target Html Elements\n@docs HtmlTarget, HtmlElement, HtmlSelector, HtmlSelectorGroup, target\n\n# Make Expectations\n@docs expect\n\n# Render the View\n@docs render\n\n",
    "unions": [],
    "aliases": [
      {
        "name": "HtmlElement",
        "comment": " Represents an Html element.\n",
        "args": [
          "msg"
        ],
        "type": "Elmer.Html.Types.HtmlElement msg"
      },
      {
        "name": "HtmlSelector",
        "comment": " Represents a function for matching an Html Element.\n\nYou can create your own `HtmlSelector`. For example, here's \nan `HtmlSelector` that matches any element that has at least one\nof the given classes:\n\n    classOf : List String -> HtmlSelector msg\n    classOf expectedClasses element =\n      { description = \n          \"one of \" ++ \n            String.join \",\" expectedClasses\n      , predicate = \n          \\element ->\n            Element.classList element\n              |> List.filter (\\c -> \n                  List.member c expectedClasses\n                )\n              |> not << List.isEmpty\n      }\n\nwhich you could use to target elements that have either the class `funny` or `awesome`\nlike so:\n\n    Elmer.Html.target \n      << by [ classOf [ \"funny\", \"awesome\" ] ]\n",
        "args": [
          "msg"
        ],
        "type": "{ description : String.String, predicate : Elmer.Html.HtmlElement msg -> Basics.Bool }"
      },
      {
        "name": "HtmlSelectorGroup",
        "comment": " Represents a group of `HtmlSelector` used to match an Html Element.\n",
        "args": [
          "msg"
        ],
        "type": "Elmer.Html.Types.HtmlSelectorGroup msg"
      },
      {
        "name": "HtmlTarget",
        "comment": " Represents the Html Element or Elements about which expectations will be made.\n\nAn `HtmlTarget` is determined by the last use of `Elmer.Html.target`.\n",
        "args": [
          "msg"
        ],
        "type": "Elmer.Html.Types.HtmlTarget msg"
      }
    ],
    "values": [
      {
        "name": "expect",
        "comment": " Make expectations about the targeted html.\n\n    testState\n      |> target << by [ class \"my-class\" ]\n      |> expect (\n        Elmer.Html.Matchers.element <|\n          Elmer.Html.Matchers.hasText \"some text\"\n      )\n\nUse `expect` in conjunction with matchers like `element`, `elementExists`,\nor `elements`.\n",
        "type": "Elmer.Matcher (Elmer.Html.HtmlTarget msg) -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "render",
        "comment": " Call the component's view function with the current model.\n\nSometimes, it may be useful to render the component's view manually. For example,\nif you are spying on some function called by the view function, you'll need to\nrender the view manually before you can make expectations about that spy.\n\nNote: Usually you will not need to render the view manually.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "target",
        "comment": " Target an element or elements within the Html produced by the\ncomponent's `view` function.\n\nUse this function to specify which element will receive an event or which should\nbe the subject of any expectations.\n\nSee `Elmer.Html.Selector` for some common selectors. For example, to target\na `div` that has a class `.some-class` and is a child of a `li` whose ancestor is an\nelement with `root` as the value of its `id` attribute:\n\n    target \n      << descendantsOf [ id \"root\" ]\n      << childrenOf [ tag \"li\" ]\n      << by [ tag \"div\", class \"some-class\" ]\n\nYou can chain as many `Elmer.Html.Selector.descendantsOf` or `Elmer.Html.Selector.childrenOf` calls\nas you like; the chain must end with a call to `Elmer.Html.Selector.by`.\n",
        "type": "( Elmer.Html.HtmlSelectorGroup msg, Elmer.TestState model msg ) -> Elmer.TestState model msg"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Html.Element",
    "comment": " Functions for working directly with HtmlElements.\n\n# Element Characteristics\n@docs tag, id, classList, styles, property, boolProperty, properties, attributes, texts, children\n\n# Target Descendants\n@docs target\n\n# Debugging\n@docs toString\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "attributes",
        "comment": " Get this element's attributes as a `Dict`. If you define a custom attribute\nfor an Html element, you can find it with this function.\n\n    Elmer.given someModel view update\n      |> target << by [ id \"some-element\" ]\n      |> expect (element <| \\element ->\n        attributes element\n          |> Dict.get \"data-attribute\"\n          |> Expect.notEqual Nothing\n      )\n",
        "type": "Elmer.Html.HtmlElement msg -> Dict.Dict String.String String.String"
      },
      {
        "name": "boolProperty",
        "comment": " Get the boolean value of a particular property belonging to\nthis element, if that property is defined.\n\nIf the property is defined, but its value is not boolean, then\n`Nothing` is returned.\n",
        "type": "String.String -> Elmer.Html.HtmlElement msg -> Maybe.Maybe Basics.Bool"
      },
      {
        "name": "children",
        "comment": " Get the Html elements that are children of this element.\n\nNote that `Html.text` values are excluded. Use `texts` to get those.\n",
        "type": "Elmer.Html.HtmlElement msg -> List.List (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "classList",
        "comment": " Get a list of classes applied to this element.\n",
        "type": "Elmer.Html.HtmlElement msg -> List.List String.String"
      },
      {
        "name": "id",
        "comment": " Get the value of the element's `id` attribute, if it is defined.\n",
        "type": "Elmer.Html.HtmlElement msg -> Maybe.Maybe String.String"
      },
      {
        "name": "properties",
        "comment": " Get this element's properties as a `Dict`.\n\nOn the difference between attributes and properties,\nsee [this](https://github.com/elm/html/blob/master/properties-vs-attributes.md).\n",
        "type": "Elmer.Html.HtmlElement msg -> Dict.Dict String.String String.String"
      },
      {
        "name": "property",
        "comment": " Get the value of a particular property belonging to this\nelement, if that property is defined.\n",
        "type": "String.String -> Elmer.Html.HtmlElement msg -> Maybe.Maybe String.String"
      },
      {
        "name": "styles",
        "comment": " Get this element's styles as a `Dict`.\n",
        "type": "Elmer.Html.HtmlElement msg -> Dict.Dict String.String String.String"
      },
      {
        "name": "tag",
        "comment": " Get the tag of the element\n",
        "type": "Elmer.Html.HtmlElement msg -> String.String"
      },
      {
        "name": "target",
        "comment": " Target descendants of an element.\n\nUse this function in conjunction with `HtmlTarget` matchers like `element` or `elements`\nto make expectations about descendants of an element.\n\n    Elmer.given someModel view update\n      |> Elmer.Html.target\n          << by [ id \"some-element\" ]\n      |> Elmer.Html.expect (Elmer.Html.Matchers.element <|\n          \\element ->\n            element\n              |> target << by [ tag \"div\" ]\n              |> Elmer.Html.Matchers.elements (\n                Elmer.hasLength 3\n              )\n        )\n\nNote that `Elmer.Html.target << descendantsOf [ id \"some-element\" ] << by [ tag \"div\" ]` would allow you to write the\nsame expectation. Use `Element.target` for complex expectations about nested elements.\n\n",
        "type": "( Elmer.Html.Types.HtmlSelectorGroup msg, Elmer.Html.HtmlElement msg ) -> Elmer.Html.HtmlTarget msg"
      },
      {
        "name": "texts",
        "comment": " Get the `Html.text` values that are children of this element.\n",
        "type": "Elmer.Html.HtmlElement msg -> List.List String.String"
      },
      {
        "name": "toString",
        "comment": " Represent an `HtmlElement` as a String.\n",
        "type": "Elmer.Html.HtmlElement msg -> String.String"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Html.Event",
    "comment": " Trigger events on targeted elements. When an event occurs, Elmer will\ncall the component's `update` method with the resulting message.\n\nElmer respects the `stopPropagation` option on event handlers. An event on an\nelement will bubble up through that element's ancestors until an event handler\nsays otherwise.\n\nThis means, for example, that you can `click` a targeted element whose\nancestor registers for click events and the event will be handled by that\nancestor as expected.\n\nThe `mouseEnter` and `mouseLeave` events are exceptions to this rule. These events only\ntrigger a handler attached to the targeted element. See `moveMouseIn` and `moveMouseOut`\nfor more.\n\n# Mouse Events\n\nAll mouse events occur at a simulated position of `{ pageX = 0, pageY = 0}`. If your\ntest needs a mouse event to occur at a specific position, use `trigger`.\n\n@docs click, doubleClick, press, release, moveMouseIn, moveMouseOut\n\n# Form Events\n@docs input, check, uncheck, select\n\n# Focus Events\n@docs focus, blur\n\n# Custom Events\n@docs trigger\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "blur",
        "comment": " Trigger a blur event on the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "check",
        "comment": " Trigger a change event on the targeted checkbox element with\n`True` for the `checked` property.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "click",
        "comment": " Simulate a click on the targeted element.\n\nA click will trigger the appropriate `click`, `mouseDown`, and `mouseUp` event\nhandlers on the targeted element or its ancestors.\n\nA click on an input element with type submit or a button element with type submit (or\na button with no type specified) will also trigger the appropriate `submit` event handlers as follows:\n- If the targeted element has a form attribute, then the submit handler\non the specified form will be triggered; if the specified form does not exist, no submit\nhandlers will be triggered.\n- If the targeted element has no form attribute, then the submit handler on any form that is an\nancestor of the targeted element will be triggered.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "doubleClick",
        "comment": " Simulate a double click on the targeted element.\n\nTwo clicks will occur in succession, with the second also triggering a double\nclick event. See `click` above for a list of the events triggered by a click.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "focus",
        "comment": " Trigger a focus event on the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "input",
        "comment": " Trigger an input event on the targeted element.\n",
        "type": "String.String -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "moveMouseIn",
        "comment": " Simulate moving the mouse into the targeted element.\n\nThis may trigger any relevant `mouseOver` or `mouseEnter` event handlers.\n\nNote: Mouse enter events do not propagate, so a mouse enter action will only\ntrigger an event handler that is registered by the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "moveMouseOut",
        "comment": " Simulate moving the mouse out of the targeted element.\n\nThis may trigger any relevant `mouseOut` or `mouseLeave` event handlers.\n\nNote: Mouse leave events do not propagate, so a mouse leave action will only\ntrigger an event handler that is registered by the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "press",
        "comment": " Trigger a mouse down event on the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "release",
        "comment": " Trigger a mouse up event on the targeted element.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "select",
        "comment": " Trigger an input event on the targeted select element.\n\nThe argument specifies the option to select by its `value` property.\n",
        "type": "String.String -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "trigger",
        "comment": " Trigger a custom event on the targeted element. Provide the name of the event\nand the proper representation of the event object in JSON format.\n\nThe following will trigger a `keyup` event:\n\n    testState\n      |> trigger \"keyup\" \"{\\\"keyCode\\\":65}\"\n",
        "type": "String.String -> String.String -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "uncheck",
        "comment": " Trigger a change event on the targeted checkbox element with\n`False` for the `checked` property.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Html.Matchers",
    "comment": " Make expectations about the Html generated by a view function.\n\n# HtmlTarget Matchers\n@docs element, elementExists, elements\n\n# HtmlElement Matchers\n@docs hasText, hasId, hasClass, hasStyle, hasAttribute, listensForEvent\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "element",
        "comment": " Make expectations about the selected element.\n\nThe matcher will fail if the selected element does not exist.\n\nIf the selector matches more than one element,\nthe given element matcher will only be applied to the first element selected.\n\n    testState\n      |> Elmer.Html.target \n          << by [ tag \"div\" ]\n      |> Elmer.Html.expect (\n          element <| hasText \"Fun Stuff\"\n        )\n\n",
        "type": "Elmer.Matcher (Elmer.Html.HtmlElement msg) -> Elmer.Matcher (Elmer.Html.HtmlTarget msg)"
      },
      {
        "name": "elementExists",
        "comment": " Expect that the selected element exists.\n\n    testState\n      |> Elmer.Html.target \n          << by [ id \"cool-element\" ]\n      |> Elmer.Html.expect elementExists\n",
        "type": "Elmer.Matcher (Elmer.Html.HtmlTarget msg)"
      },
      {
        "name": "elements",
        "comment": " Make expectations about the selected elements.\n\nIf the selector fails to match any elements, an empty list will\nbe passed to the given matcher.\n\n    testState\n      |> Elmer.Html.target \n          << by [ tag \"li\" ]\n      |> Elmer.Html.expect (\n          elements <| Elmer.hasLength 4\n        )\n",
        "type": "Elmer.Matcher (List.List (Elmer.Html.HtmlElement msg)) -> Elmer.Matcher (Elmer.Html.HtmlTarget msg)"
      },
      {
        "name": "hasAttribute",
        "comment": " Expect that an element has the specified attribute or property with the specified value.\n\n    testState\n      |> Elmer.Html.target\n          << by [ id \"fun-element\" ]\n      |> Elmer.Html.expect (element <|\n          hasAttribute ( \"src\", \"http://fun.com\" )\n        )\n\nOn the difference between attributes and properties,\nsee [this](https://github.com/elm-lang/html/blob/master/properties-vs-attributes.md).\n",
        "type": "( String.String, String.String ) -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "hasClass",
        "comment": " Expect that an element has the specified class. No need to prepend the class name with a dot.\n",
        "type": "String.String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "hasId",
        "comment": " Expect that an element has the specified id. No need to prepend the id with a pound sign.\n",
        "type": "String.String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "hasStyle",
        "comment": " Expect that an element has the specified style.\n\n    hasStyle (\"left\", \"20px\") element\n\n",
        "type": "( String.String, String.String ) -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "hasText",
        "comment": " Expect that an element has some text. This matcher will pass only if the element\nor any of its descendents contains some `Html.text` with the specified text.\n",
        "type": "String.String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      },
      {
        "name": "listensForEvent",
        "comment": " Expect that an element listens for an event of the given type.\n\n    testState\n      |> Elmer.Html.target\n          << by [ id \"fun-element\" ]\n      |> Elmer.Html.expect (element <|\n          listensForEvent \"click\"\n        )\n\nNote: This will not consider event handlers on the element's ancestors.\n",
        "type": "String.String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Html.Selector",
    "comment": " Functions for selecting Html elements to be targeted during a test.\n\n# Basic Selectors\n@docs id, tag, class, attribute, attributeName, text\n\n# Group Selectors\n@docs by, descendantsOf, childrenOf\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "attribute",
        "comment": " Select Html elements that have an attribute or property with the given name and value.\n\nOn the difference between attributes and properties,\nsee [this](https://github.com/elm-lang/html/blob/master/properties-vs-attributes.md).\n",
        "type": "( String.String, String.String ) -> Elmer.Html.HtmlSelector msg"
      },
      {
        "name": "attributeName",
        "comment": " Select Html elements that have an attribute or proprty with the given name, regardless of the associated value.\n\nOn the difference between attributes and properties,\nsee [this](https://github.com/elm-lang/html/blob/master/properties-vs-attributes.md).\n",
        "type": "String.String -> Elmer.Html.HtmlSelector msg"
      },
      {
        "name": "by",
        "comment": " Select Html elements that match all the given selectors.\n\nThis would select all `div` elements that have the class `some-class`:\n\n    testState\n      |> Elmer.Html.target\n          << by [ tag \"div\", class \"some-class\" ]\n",
        "type": "List.List (Elmer.Html.HtmlSelector msg) -> targetable -> ( Elmer.Html.HtmlSelectorGroup msg, targetable )"
      },
      {
        "name": "childrenOf",
        "comment": " Narrow the scope of further selections to those elements that are children of the selected elements.\n\nSuppose you want to select all `li` that are children of an `ol`:\n\n    testState\n      |> Elmer.Html.target\n        << childrenOf [ tag \"ol\" ]\n        << by [ tag \"li\" ]\n",
        "type": "List.List (Elmer.Html.HtmlSelector msg) -> ( Elmer.Html.HtmlSelectorGroup msg, targetable ) -> ( Elmer.Html.HtmlSelectorGroup msg, targetable )"
      },
      {
        "name": "class",
        "comment": " Select Html elements by css class. \n",
        "type": "String.String -> Elmer.Html.HtmlSelector msg"
      },
      {
        "name": "descendantsOf",
        "comment": " Narrow the scope of further selections to descendants of the selected elements.\n\nSuppose you want to select all `li` that are descendants of an `ol` that is itself a descendant of\nan element with a particular class:\n\n    testState\n      |> Elmer.Html.target\n        << descendantsOf [ class \"some-class\" ]\n        << descendantsOf [ tag \"ol\" ]\n        << by [ tag \"li\" ]\n\nYou can chain as many `descendantsOf` calls as you like, but the chain must be terminated with a call to `by`.\n",
        "type": "List.List (Elmer.Html.HtmlSelector msg) -> ( Elmer.Html.HtmlSelectorGroup msg, targetable ) -> ( Elmer.Html.HtmlSelectorGroup msg, targetable )"
      },
      {
        "name": "id",
        "comment": " Select Html elements by id.\n",
        "type": "String.String -> Elmer.Html.HtmlSelector msg"
      },
      {
        "name": "tag",
        "comment": " Select Html elements by tag name.\n",
        "type": "String.String -> Elmer.Html.HtmlSelector msg"
      },
      {
        "name": "text",
        "comment": " Select Html elements that have the given text as an immediate descendant.\n\nFor example,\n\n    testState\n      |> target << by [ text \"Some text\" ]\n\nwould select only the `p` element in the following:\n\n    Html.div []\n    [ Html.p [] [ Html.text \"Some text\" ]\n    ]\n\n",
        "type": "String.String -> Elmer.Html.HtmlSelector msg"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Http",
    "comment": " Functions for handling Http requests in your tests.\n\nYour component makes Http requests. You want to describe the behavior of your\ncomponent. What to do?\n\n1. Create an HttpResponseStub -- see `Elmer.Http.Stub`\n\n2. Serve it up during your test\n\n3. Smile!\n\n# Serve Stubbed Responses\n@docs HttpResponseStub, serve, spy\n\n# Make Expectations about Http Requests\n@docs expectRequest, expect, clearRequestHistory\n\n",
    "unions": [],
    "aliases": [
      {
        "name": "HttpResponseStub",
        "comment": " Represents a stubbed HttpResponse\n\nUse `Elmer.Http.Stub` to build an `HttpResponseStub`.\n",
        "args": [],
        "type": "Elmer.Http.Types.HttpResponseStub"
      }
    ],
    "values": [
      {
        "name": "clearRequestHistory",
        "comment": " Clear any Http requests that may have been recorded at an earlier point\nin the history of this TestState.\n",
        "type": "Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "expect",
        "comment": " Make some expectation about requests to the specified route.\n\n    expect (Elmer.Http.Route.get \"http://fun.com/fun\") (\n      Elmer.each <| \n        Elmer.Http.Matchers.hasHeader \n          (\"X-Auth-Token\", \"MY-TOKEN\")\n    )\n\nIf no requests have been made to the specified route, an empty list\nwill be passed to the `Matcher (List HttpRequest)`.\n\nNote: This must be used in conjunction with `Elmer.Http.serve` or `Elmer.Http.spy`.\n",
        "type": "Elmer.Http.Route.HttpRoute -> Elmer.Matcher (List.List Elmer.Http.Request.HttpRequest) -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "expectRequest",
        "comment": " Expect one or more requests to the specified route.\n\nIf no requests have been made to the specified route, the test will fail.\n\nNote: This must be used in conjunction with `Elmer.Http.serve` or `Elmer.Http.spy`.\n",
        "type": "Elmer.Http.Route.HttpRoute -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "serve",
        "comment": " Override `Http.send` and `Http.toTask` to register HttpResponseStubs that will be\nreturned when the appropriate request is received. Used in conjunction with\n`Elmer.Spy.use`.\n\nSuppose you have a component that requests information about a user when\na button is clicked. You could register a stub for that request like so\n\n    let\n      stubbedResponse = \n        Elmer.Http.Stub.for (\n          Elmer.Http.Route.post \"http://fun.com/user\"\n        ) \n          |> Elmer.Http.Stub.withBody\n            \"{\\\"name\\\":\\\"Super User\\\"}\"\n    in\n      testState\n        |> Spy.use [ serve [ stubbedResponse ] ]\n        |> Markup.target\n            << by [ id \"submit-button\" ]\n        |> Elmer.Html.Event.click\n        |> Markup.target\n            << by [ id \"result\" ]\n        |> Markup.expect (Matchers.element <| \n            Matchers.hasText \"Hello, Super User!\"\n          )\n\n",
        "type": "List.List Elmer.Http.HttpResponseStub -> Elmer.Spy.Spy"
      },
      {
        "name": "spy",
        "comment": " Override `Http.send` and `Http.toTask` to record requests as they are received.\nUsed in conjunction with `Elmer.Spy.use`.\n\nSuppose you simply want to make an expectation about a request without\ndescribing the behavior that results when its response is received.\n\n    testState\n      |> Spy.use [ spy ]\n      |> Markup.target \"#submit-button\"\n      |> Elmer.Http.Event.click\n      |> Elmer.Http.expectRequest (\n          Elmer.Http.Route.get \"http://fun.com/user\"\n        )\n\nNote: When using `spy` in conjunction with `Http.toTask`, the task chain will\nstop at the first http request, since Elmer can't decide how to go on without\nknowing the response from the request.\n",
        "type": "Elmer.Spy.Spy"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Http.Matchers",
    "comment": " Make expectations about Http requests sent by the component under test.\n\nThese matchers should be used with `Elmer.Http.expect`.\n\nNote: Your test must use `Elmer.Http.serve` or `Elmer.Http.spy` at the\nappropriate time to allow Elmer to record the requests sent by the component\nunder test.\n\n# Matchers\n@docs wasRequested, hasBody, hasQueryParam, hasHeader\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "hasBody",
        "comment": " Match a request with the specified body.\n\n    Elmer.Http.expect (Elmer.Http.Route.post \"http://fake.com/fake\") (\n      Elmer.some <| \n        hasBody \"{\\\"name\\\":\\\"Fun Person\\\"}\"\n    )\n\n",
        "type": "String.String -> Elmer.Matcher Elmer.Http.Request.HttpRequest"
      },
      {
        "name": "hasHeader",
        "comment": " Match a request with the specified header name and value.\n\n    Elmer.Http.expect (Elmer.Http.Route.get \"http://fake.com/fake\") (\n      Elmer.some <| \n        hasHeader ( \"x-auth-token\", \"xxxxx\" )\n    )\n\n",
        "type": "( String.String, String.String ) -> Elmer.Matcher Elmer.Http.Request.HttpRequest"
      },
      {
        "name": "hasQueryParam",
        "comment": " Match a request that has a query string containing the specified name and value.\n\nNote: You don't need to worry about url encoding the name or value.\n\n    Elmer.Http.expect (Elmer.Http.Route.get \"http://fake.com/fake\") (\n      Elmer.some <| \n        hasQueryParam ( \"name\", \"Fun Person\" )\n    )\n\n",
        "type": "( String.String, String.String ) -> Elmer.Matcher Elmer.Http.Request.HttpRequest"
      },
      {
        "name": "wasRequested",
        "comment": " Expect that exactly some number of requests have been recorded.\n\n    Elmer.Http.expect (Elmer.Http.Route.get \"http://fun.com/fun.html\") (\n      wasRequested 3\n    )\n",
        "type": "Basics.Int -> Elmer.Matcher (List.List Elmer.Http.Request.HttpRequest)"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Http.Request",
    "comment": " Functions for working with a recorded HTTP request.\n\n@docs HttpRequest, body, queryString, headers\n\n",
    "unions": [],
    "aliases": [
      {
        "name": "HttpRequest",
        "comment": " Represents a recorded HTTP request about which expectations may be made.\n",
        "args": [],
        "type": "Elmer.Http.Types.HttpRequest"
      }
    ],
    "values": [
      {
        "name": "body",
        "comment": " Get the body of a recorded HTTP request.\n",
        "type": "Elmer.Http.Request.HttpRequest -> Maybe.Maybe String.String"
      },
      {
        "name": "headers",
        "comment": " Get the headers of a recorded HTTP request as a list of (name, value) tuples. \n",
        "type": "Elmer.Http.Request.HttpRequest -> List.List ( String.String, String.String )"
      },
      {
        "name": "queryString",
        "comment": " Get the query string of a recorded HTTP request, if it exists\n",
        "type": "Elmer.Http.Request.HttpRequest -> Maybe.Maybe String.String"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Http.Result",
    "comment": " Functions for working with the stubbed result of an HTTP request.\n\n@docs HttpResult, withBody, withHeader, withStatus\n\n",
    "unions": [],
    "aliases": [
      {
        "name": "HttpResult",
        "comment": " Represents the stubbed result of an HTTP request.\n",
        "args": [],
        "type": "Elmer.Http.Types.HttpResult"
      }
    ],
    "values": [
      {
        "name": "withBody",
        "comment": " Set the body of an HttpResult.\n\nIf the given HttpResult is set to return an error, then this function\nwill do nothing. \n",
        "type": "String.String -> Elmer.Http.Result.HttpResult -> Elmer.Http.Result.HttpResult"
      },
      {
        "name": "withHeader",
        "comment": " Add a header to an HttpResult.\n\nIf the given HttpResult is set to return an error, then this function\nwill do nothing. \n",
        "type": "( String.String, String.String ) -> Elmer.Http.Result.HttpResult -> Elmer.Http.Result.HttpResult"
      },
      {
        "name": "withStatus",
        "comment": " Set the status of an HttpResult.\n\nIf the given HttpResult is set to return an error, then this function\nwill do nothing.\n",
        "type": "Elmer.Http.Status.HttpStatus -> Elmer.Http.Result.HttpResult -> Elmer.Http.Result.HttpResult"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Http.Route",
    "comment": " Functions for working with HTTP routes.\n\nA route is an HTTP request method plus a URL, up to but not including a query string.\n\n# Creating an HttpRoute\n@docs HttpRoute, get, post, delete, put, patch\n\n# Accessing an HttpRoute\n@docs method, url\n\n",
    "unions": [],
    "aliases": [
      {
        "name": "HttpRoute",
        "comment": " Represents an HTTP route, which is a URL plus an HTTP request method.\n",
        "args": [],
        "type": "Elmer.Http.Types.HttpRoute"
      }
    ],
    "values": [
      {
        "name": "delete",
        "comment": " Create a route for an HTTP DELETE.\n\n    delete \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String.String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "get",
        "comment": " Create a route for an HTTP GET.\n\n    get \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String.String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "method",
        "comment": " Return the route's method.\n",
        "type": "Elmer.Http.Route.HttpRoute -> String.String"
      },
      {
        "name": "patch",
        "comment": " Create a route for an HTTP PATCH.\n\n    patch \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String.String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "post",
        "comment": " Create a route for an HTTP POST.\n\n    post \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String.String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "put",
        "comment": " Create a route for an HTTP PUT.\n\n    put \"http://funstuff.com\"\n\nIf the given url contains a query string, it will be ignored.\n",
        "type": "String.String -> Elmer.Http.Route.HttpRoute"
      },
      {
        "name": "url",
        "comment": " Return the route's url.\n",
        "type": "Elmer.Http.Route.HttpRoute -> String.String"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Http.Status",
    "comment": " Functions for working with Http status codes.\n\n# General\n@docs HttpStatus, httpStatus\n\n# Common Status Codes\n@docs ok, created, unauthorized, forbidden, notFound, serverError\n\n",
    "unions": [],
    "aliases": [
      {
        "name": "HttpStatus",
        "comment": " Represents the status of an Http response\n",
        "args": [],
        "type": "Elmer.Http.Types.HttpStatus"
      }
    ],
    "values": [
      {
        "name": "created",
        "comment": " The `201 Created` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "forbidden",
        "comment": " The `403 Forbidden` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "httpStatus",
        "comment": " Generate an `HttpStatus`.\n",
        "type": "Basics.Int -> String.String -> Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "notFound",
        "comment": " The `404 Not Found` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "ok",
        "comment": " The `200 OK` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "serverError",
        "comment": " The `500 Internal Server Error` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      },
      {
        "name": "unauthorized",
        "comment": " The `401 Unauthorized` Http status.\n",
        "type": "Elmer.Http.Status.HttpStatus"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Http.Stub",
    "comment": " Functions for building stubbed responses to Http requests.\n\n# Create a stubbed response\n@docs for\n\n# Describe the Response\n@docs withBody, withHeader, withStatus, withError\n\n# Provide a Result based on the Request\n@docs withResult\n\n# Defer the Response\n@docs deferResponse\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "deferResponse",
        "comment": " Defer a response.\n\nThe response will not be processed until `Elmer.Command.resolveDeferred` is called.\n\nNote: If this stub is processed as part of a request made with `Http.toTask` then the\nentire Task chain will be deferred until `Elmer.Command.resolveDeferred` is called.\n\n",
        "type": "Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "for",
        "comment": " Stub the response for a request to the specified route.\n\nBy default, this response will return an empty body with a status of\n`200 OK`.\n",
        "type": "Elmer.Http.Route.HttpRoute -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "withBody",
        "comment": " Build a response stub that returns the specified string as its body.\n\nSuppose you want to describe the behavior that results when a response body is\nparsed. You could create a stub like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.post \"http://fake.com/fake\")\n      |> withBody \"{\\\"name\\\":\\\"Fun Person\\\"}\"\n\n",
        "type": "String.String -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "withError",
        "comment": " Build a response stub that results in an `Http.Error`.\n\nSuppose you want to describe the behavior that should result when a request\ntimes out. You could create a stubbed response like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.get \"http://fake.com/fake\")\n      |> withError Http.Error.Timout\n\n",
        "type": "Http.Error -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "withHeader",
        "comment": " Build a response stub that has the specified header.\n\nAdd as many headers as necessary like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.post \"http://fake.com/fake\")\n      |> withBody \"{\\\"name\\\":\\\"Fun Person\\\"}\"\n      |> withHeader (\"x-fun-header\", \"something fun\")\n      |> withHeader (\"x-awesome-header\", \"something awesome\")\n",
        "type": "( String.String, String.String ) -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "withResult",
        "comment": " Build a response stub that generates an HttpResult based on the matching\nHttpRequest.\n\nYou could create a stub that returns a body only given a certain query string like so:\n\n    Elmer.Http.Stub.for (\n        Elmer.Http.Route.post \"http://fake.com/fake\"\n    )\n      |> withResult (\\request ->\n        let\n          hasBowling =\n            Elmer.Http.Request.queryString request\n              |> String.contains \"sport=bowling\"\n        in\n          if hasBowling then\n            Elmer.Http.Result.withBody\n              \"{\\\"sport\\\":\\\"bowling\\\"}\"\n          else\n            Elmer.Http.Result.withStatus\n              Elmer.Http.Status.notFound\n      )\n",
        "type": "(Elmer.Http.Request.HttpRequest -> Elmer.Http.Result.HttpResult -> Elmer.Http.Result.HttpResult) -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      },
      {
        "name": "withStatus",
        "comment": " Build a response stub that returns some particular status.\n\nSuppose you want to describe the behavior that should result when a request\nreturns a `500 Internal Server Error`. You could create a stubbed response like so:\n\n    Elmer.Http.Stub.for (Elmer.Http.Route.get \"http://fake.com/fake\")\n      |> withStatus \n          Elmer.Http.Status.serverError\n\n",
        "type": "Elmer.Http.Status.HttpStatus -> Elmer.Http.HttpResponseStub -> Elmer.Http.HttpResponseStub"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Navigation",
    "comment": " Functions for describing the navigation behavior of Elm Html programs created with `Browser.application`.\n\n# Make Expectations about the Current Location\n@docs spy, expectLocation\n\n# Get a Fake Navigation Key\n@docs fakeKey\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "expectLocation",
        "comment": " Expect that the current location is equal to the given string.\n\nThis expectation must be used in conjunction with `spy` above, and your `TestState` must be \ncreated with `Elmer.Program.givenApplication`. \n\nSuppose your app calls `Browser.Navigation.pushUrl` when an element is clicked. You can describe\nthis behavior as follows: \n\n    Elmer.Program.givenApplication App.OnUrlRequest App.OnUrlChange App.view App.update\n      |> Elmer.Spy.use [ Elmer.Navigation.spy ]\n      |> Elmer.Program.init (\\_ -> \n          App.init testFlags testUrl Elmer.Navigation.fakeKey\n        )\n      |> Elmer.Html.target\n          << by [ id \"some-element\" ]\n      |> Elmer.Html.Event.click\n      |> Elmer.Navigation.expectLocation\n          \"http://mydomain.com/funStuff.html\"\n\nNote that `expectLocation` will only match on urls provided via `Browser.Navigation.pushUrl` or\n`Browser.Navigation.replaceUrl`. In particular, `expectLocation` will not match the url provided\nas part of the call to `Elmer.init` that provides the initial model and command values. \n",
        "type": "String.String -> Elmer.Matcher (Elmer.TestState model msg)"
      },
      {
        "name": "fakeKey",
        "comment": " Generate a fake `Browser.Navigation.Key` value.\n\nUse this value when calling the init function of a `Browser.application` program during a test.\n",
        "type": "Browser.Navigation.Key"
      },
      {
        "name": "spy",
        "comment": " Stub `Browser.Navigation.pushUrl` and `Browser.Navigation.replaceUrl` with a function that\nrecords the location as it is set.\n\nYou must use this function with `Elmer.Spy.use` in order to make expectations\nabout the location.\n\nSuppose you want to test a home button that sets the\nlocation to `/home` when clicked:\n\n    testState\n      |> Spy.use [ Navigation.spy ]\n      |> Elmer.Html.target \n          << by [ id \"home-button\" ]\n      |> Elmer.Html.Event.click\n      |> Elmer.Navigation.expectLocation \"/home\"\n\n",
        "type": "Elmer.Spy.Spy"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Program",
    "comment": " Functions for working with Elm programs.\n\n# Test an Elm Html Sandbox or Element Program\n@docs givenElement\n\n# Test an Elm Html Application\n@docs givenApplication\n\n# Test an Elm Html Document\n@docs givenDocument\n\n# Test am Elm Worker Program\n@docs givenWorker\n\n# Initialize an Elm program\n@docs init\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "givenApplication",
        "comment": " Initialize a `TestState` with the basic requirements for a program\ncreated with `Browser.application`. \n\nThe arguments are:\n\n1. Function that maps a new `Browser.UrlRequest` to a `msg`\n2. Function that maps a `Url` to a `msg` when the url changes\n3. View function that results in a `Browser.Document`\n4. Update function\n\nYou'll need to call `Elmer.Program.init` with the program's `init` function to properly\nstart your test.\n",
        "type": "(Browser.UrlRequest -> msg) -> (Url.Url -> msg) -> (model -> Browser.Document msg) -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"
      },
      {
        "name": "givenDocument",
        "comment": " Initialize a `TestState` with the basic requirements for a program\ncreated with `Browser.document`.\n\nThe arguments are:\n\n1. View function that results in a `Browser.Document`\n2. Update function.\n\nYou'll need to call `Elmer.Program.init` with the program's `init` function to properly\nstart your test.\n",
        "type": "(model -> Browser.Document msg) -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"
      },
      {
        "name": "givenElement",
        "comment": " Initialize a `TestState` with the basic requirements for a program created with\n`Browser.sandbox` or `Browser.element`.\n\nThe arguments are:\n\n1. View function\n2. Update function\n\nYou'll need to call `Elmer.Program.init` with the program's `init` function to properly\nstart your test.\n",
        "type": "(model -> Html.Html msg) -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"
      },
      {
        "name": "givenWorker",
        "comment": " Initialize a `TestState` with the basic requirements for\na headless worker program created with `Platform.worker`.\n\nThe argument is an update function.\n\nYou'll need to call `Elmer.Program.init` with the program's `init` function to properly\nstart your test.\n",
        "type": "(msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"
      },
      {
        "name": "init",
        "comment": " Update the test context with the given model and Cmd.\n\nProvide a function that calls a program's `init` function and returns a model and a command. \nThe resuling model will become the current model for the system under test and the given command\nwill be executed. \n\n    Elmer.Program.givenDocument MyDocument.view MyDocument.update\n      |> init (\\() -> MyDocument.init)\n      |> Elmer.Html.target\n          << by [ id \"title\" ]\n      |> Elmer.Html.expectElementExists\n\nNote: If your test requires any spies, call `Spy.use` before your call to `init` so the spies will\nbe available whan the supplied function is evaluated.\n",
        "type": "(() -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Program.Matchers",
    "comment": " Make expectations about the Document generated by a view function.\n\n# Document Matchers\n@docs expectTitle\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "expectTitle",
        "comment": " Expect that a document has some title.\n",
        "type": "String.String -> Elmer.Matcher (Elmer.TestState model msg)"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Spy",
    "comment": " Functions for spying during tests.\n\n@docs Spy, Calls\n\n# Spy on a Real Function\n@docs create, andCallFake, replaceValue\n\n# Spy on a Provided Function\n@docs createWith, callable\n\n# Use a Spy\n@docs use\n\n# Make Expectations about a Spy\n@docs expect\n\n",
    "unions": [],
    "aliases": [
      {
        "name": "Calls",
        "comment": " Represents the calls made to a spy.\n",
        "args": [],
        "type": "Elmer.Spy.Internal.Calls"
      },
      {
        "name": "Spy",
        "comment": " Represents a function that has been spied on.\n",
        "args": [],
        "type": "Elmer.Spy.Internal.Spy"
      }
    ],
    "values": [
      {
        "name": "andCallFake",
        "comment": " Call the provided function when a Spy is called.\n\nOnce you've created a `Spy`, you can provide a fake implementation like so:\n\n    mySpy =\n      create \"my-spy\" (\\_ ->\n        MyModule.someFunction\n      )\n        |> andCallFake testImplementation\n\nwhere `testImplementation` is some function with the very same signature as\nthe one being spied upon.\n\nIf you are spying on a function that returns a `Cmd`, then your fake\nshould return `Cmd.none` or one of the fake commands described in `Elmer.Command`.\n\nFor example, you could override `Random.generate` so that it returns a set value during a test\nlike so:\n\n    Elmer.Spy.create \"fake-random\" (\\_ -> \n      Random.generate\n    )\n      |> andCallFake (\\tagger generator ->\n        Random.initialeSeed 10001\n          |> Random.step generator\n          |> tagger\n          |> Elmer.Command.fake\n      )\n\nIf you are spying on a function that returns a `Sub`, then your fake should\nreturn a fake subscription; see `Elmer.Subscription.fake`.\n\nNote: The fake implementation will not be active until you register this spy\nvia `use`.\n\n",
        "type": "(a -> b) -> Elmer.Spy.Spy -> Elmer.Spy.Spy"
      },
      {
        "name": "callable",
        "comment": " Returns a function that records calls to itself and calls through to the function\nassociated with the spy with the given name.\n\nNote: Use `callable` only in conjunction with spies produced using `createWith`; otherwise\nyou'll receive an error.\n",
        "type": "String.String -> a -> b"
      },
      {
        "name": "create",
        "comment": " Create a spy for a function.\n\nTo create a spy for a function, pass in a string to identify the spy and a function that returns the\nfunction you want spy on.\n\nUse a spy when you want to know that a function was called.\n\nTo use the spy, pass the `Spy` to `use`. When the spied upon function is called,\nElmer will record that it has been called. By defalut, Elmer will then call\nthrough to the original function.\n\n    let\n      mySpy =\n        create \"my-spy\" (\\_ -> \n          MyModule.someFunction\n        )\n    in\n      testState\n        |> use [ mySpy ]\n        |> expect \"my-spy\" (wasCalled 0)\n\n",
        "type": "String.String -> (() -> a) -> Elmer.Spy.Spy"
      },
      {
        "name": "createWith",
        "comment": " Create a spy for a function you provide.\n\nLet's say you're testing a function that has a function for one of its arguments.\nIn your test, you may want to provide some function that simulates certain\nconditions. If you want to assert that the provided function is itself called\nwith certain arguments, use `createWith` to construct a spy for that function.\n\nWhen you pass the spied upon function to the function under test, use `Spy.call`\nwhich will return a version of the function that records its calls.\n\nFor example, let's say you want to inject some dependencies into your update\nfunction to decouple application logic from view logic. You would create a spy\nwith a function you provide for your test. Then, use `Spy.callable` when you want\nto provide a version of the function that will record its calls.\n\n    let\n      spy =\n        createWith \"my-spy\" (tagger ->\n          Command.fake <| tagger \"Success!\"\n        )\n      updateForTest =\n        MyModule.updateUsing <|\n          Spy.callable \"my-spy\"\n    in\n      Elmer.given testModel MyModule.view updateForTest\n        |> Elmer.Spy.use [ spy ]\n        |> Elmer.Html.target\n            << by [ tag \"input\" ]\n        |> Elmer.Html.Event.input \"some text\"\n        |> Elmer.Html.target\n            << by [ tag \"button\" ]\n        |> Elmer.Html.Event.click\n        |> Elmer.Spy.expect \"my-spy\" (\n          Elmer.Spy.Matchers.wasCalledWith\n            [ Elmer.Spy.Matchers.stringArg \"some text\"\n            ]\n        )\n\nNote: Using `andCallFake` with a spy produced via `createWith` will replace the\nprovided function.\n",
        "type": "String.String -> (a -> b) -> Elmer.Spy.Spy"
      },
      {
        "name": "expect",
        "comment": " Make an expectation about a spy.\n\nSee `Elmer.Spy.Matchers` for matchers to use with this function.\n\n    let\n      mySpy =\n        create \"my-spy\" (\\_ -> \n          MyModule.someFunction\n        )\n    in\n      testState\n        |> use [ mySpy ]\n        |> expect \"my-spy\" (wasCalled 0)\n\n",
        "type": "String.String -> Elmer.Matcher Elmer.Spy.Calls -> Elmer.TestState model msg -> Expect.Expectation"
      },
      {
        "name": "replaceValue",
        "comment": " Stub a function that simply returns a value.\n\nSuppose you have a function like `Time.now` that takes no arguments and simply\nreturns a value. You can specify the value returned by such a function during your\ntest like so:\n\n    timeNowSpy : Spy\n    timeNowSpy =\n      Task.succeed (Time.millisToPosix 1000)\n        |> Spy.replaceValue (\\_ -> Time.now)\n\nNote: It's not possible to make expectations about spies constructed\nwith `replaceValue`.\n\nNote: An error will result if you attempt to use `replaceValue`\nwith a function that has arguments.\n\n",
        "type": "(() -> a) -> b -> Elmer.Spy.Spy"
      },
      {
        "name": "use",
        "comment": " Install spies for use during the test.\n\nSuppose your component contains a button that,\nwhen clicked, issues a command to get a random number and updates the view. To\nget the random number, in your code you'll need to use `Random.generate` with the\nappropriate `Generator`. To describe this behavior in your test,\nyou could do something like the following:\n\n    let\n      randomSpy =\n        create \"fake-random\" (\\_ -> Random.generate)\n          |> andCallFake (\\tagger _ ->\n            tagger 27\n              |> Elmer.Command.fake\n          )\n    in\n      testState\n        |> use [ taskOverride ]\n        |> Elmer.Html.target \n            << by [ id \"get-random\" ]\n        |> Elmer.Html.Event.click\n        |> Elmer.Html.target\n            << by [ id \"current-random\" ]\n        |> Elmer.Html.expect (\n          Elmer.Html.Matchers.element <|\n            Elmer.Html.Matchers.hasText \"27\"\n        )\n\nNote: If you need to replace a spy during the course of a test, you may\ncall `use` again with the new spy. Each time you call `use` *all* spies\nwill be removed. So be sure that each time you call `use` you register all\nthe spies you need.\n",
        "type": "List.List Elmer.Spy.Spy -> Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Spy.Matchers",
    "comment": " Matchers for making expectations about Spies.\n\n# General Expectations\n@docs wasCalled, wasCalledWith\n\n# Expectations About Calls\n@docs Call, calls, hasArgs\n\n# Argument Matchers\n@docs Arg, argThat, anyArg, stringArg, intArg, floatArg, boolArg, typedArg, functionArg\n\n",
    "unions": [],
    "aliases": [
      {
        "name": "Arg",
        "comment": " Represents an expected function argument.\n",
        "args": [],
        "type": "Elmer.Spy.Arg.Arg"
      },
      {
        "name": "Call",
        "comment": " Represents a particular call to a spy.\n",
        "args": [],
        "type": "List.List Elmer.Spy.Matchers.Arg"
      }
    ],
    "values": [
      {
        "name": "anyArg",
        "comment": " Matches any argument.\n",
        "type": "Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "argThat",
        "comment": " Matches an argument whose value satisfies the given matcher.\n\nSuppose you want to expect that the second argument to a function is a record\nwith a specific value for its name attribute. You could do something like this:\n\n    Spy.expect \"my-spy\" (\n      wasCalledWith\n        [ anyArg\n        , argThat <|\n          \\model ->\n            model.name\n              |> Expect.equal \"Awesome Person\"\n        ]\n    )\n\nNote: Bad things will happen if you provide a matcher to `argThat` for a type\nthat is different from that of the argument you are trying to match.\n\n",
        "type": "Elmer.Matcher a -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "boolArg",
        "comment": " Matches an argument with the given boolean value.\n",
        "type": "Basics.Bool -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "calls",
        "comment": " Make expectations about the calls recorded by this spy.\n\nHere's how you would expect that exactly 2 of the calls had a certain argument.\n\n    Spy.expect \"my-spy\" (\n      calls <| Elmer.exactly 2 <|\n        hasArgs\n        [ stringArg \"some argument\"\n        ]\n    )\n\n",
        "type": "Elmer.Matcher (List.List Elmer.Spy.Matchers.Call) -> Elmer.Matcher Elmer.Spy.Calls"
      },
      {
        "name": "floatArg",
        "comment": " Matches an argument with the given float value.\n",
        "type": "Basics.Float -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "functionArg",
        "comment": " Matches an argument that is a function.\n",
        "type": "Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "hasArgs",
        "comment": " Expect that a call has some arguments.\n\nUse `hasArgs` in conjunction with `calls` to make an expectation about the args\nof a specific call.\n\n    Spy.expect \"my-spy\" (\n      calls <| Elmer.atIndex 2 <| hasArgs\n        [ stringArg \"Some String\"\n        , typedArg someTypedValue\n        ]\n    )\n\n",
        "type": "List.List Elmer.Spy.Matchers.Arg -> Elmer.Matcher Elmer.Spy.Matchers.Call"
      },
      {
        "name": "intArg",
        "comment": " Matches an argument with the given integer.\n",
        "type": "Basics.Int -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "stringArg",
        "comment": " Matches an argument with the given string.\n",
        "type": "String.String -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "typedArg",
        "comment": " Matches an argument with the given typed value.\n\nNote: You may not match what you want if your typed value contains a function reference.\n",
        "type": "a -> Elmer.Spy.Matchers.Arg"
      },
      {
        "name": "wasCalled",
        "comment": " Expect that a spy was called some number of times.\n\nThis is shorthand for:\n\n    Spy.expect \"my-spy\" (calls <| \n      Elmer.hasLength 2\n    )\n\n",
        "type": "Basics.Int -> Elmer.Matcher Elmer.Spy.Calls"
      },
      {
        "name": "wasCalledWith",
        "comment": " Expect that a spy was called at least once with the given arguments.\n\n    Spy.expect \"my-spy\" (\n      wasCalledWith\n        [ stringArg \"Some String\"\n        , typedArg someTypedValue\n        ]\n    )\n\nThis is shorthand for:\n\n    Spy.expect \"my-spy\" (\n      calls <| Elmer.some <| hasArgs\n        [ stringArg \"Some String\"\n        , typedArg someTypedValue\n        ]\n    )\n\n",
        "type": "List.List Elmer.Spy.Matchers.Arg -> Elmer.Matcher Elmer.Spy.Calls"
      }
    ],
    "binops": []
  },
  {
    "name": "Elmer.Subscription",
    "comment": " Functions for dealing with subscriptions during your test.\n\nElmer allows you to manage the effects of subscriptions yourself, so you can\ndescribe the behavior of a component under whatever conditions you need.\n\nTo manage the effects of a subscription, you'll need to do three things.\n\n1. Stub the function in your code that produces the subscription so that\nit returns a fake subscription.\n\n2. Use `with` to register the subscription during your test.\n\n2. Use `send` to send data for that subscription to your component.\n\n3. Enjoy.\n\nNote: Elmer supports `Platform.Sub.batch` and `Platform.Sub.map` so you can use these in your\ncomponent as expected.\n\n# Register Subscriptions\n@docs with\n\n# Create a Fake Subscription\n@docs fake\n\n# Send Data for a Subscription\n@docs send\n\n",
    "unions": [],
    "aliases": [],
    "values": [
      {
        "name": "fake",
        "comment": " Generate a fake subscription with an identifier and the appropriate tagger.\n\nUse `Elmer.Spy.create` along with `Elmer.Spy.andCallFake` to stub a function\nthat generates a subscription so that it returns a fake instead. Then, once\nthe faked subscription is registered using `with`,\nyou can `send` data on behalf of it subscription during your test.\n\nHere's an example that creates a fake subscription for a port called `receiveMessage`, \nregisters it and sends some data through it.\n\n    let\n      subSpy =\n        Elmer.Spy.create \"fake-port\" (\\_ ->\n          MyPortModule.receiveMessage\n        )\n        |> Elmer.Spy.andCallFake (\\tagger ->\n          Elmer.Subscription.fake \"receiveMessage\" tagger\n        )\n    in\n      Elmer.given defaultModel view update\n        |> Elmer.Spy.use [ subSpy ]\n        |> with (\\() -> subscriptions)\n        |> send \"receiveMessage\" \"Hello!\"\n\n",
        "type": "String.String -> (a -> msg) -> Platform.Sub.Sub msg"
      },
      {
        "name": "send",
        "comment": " Send data on behalf of the identified subscription.\n\nData sent via this function will be tagged accordingly and passed to\nthe component's `update` function for processing.\n",
        "type": "String.String -> a -> Elmer.TestState model msg -> Elmer.TestState model msg"
      },
      {
        "name": "with",
        "comment": " Register fake subscriptions for use during your test.\n\nSuppose your component updates the view with the new time every second. To\nget the time every second, in your code you'll need to create a `subscriptions`\nfunction that returns `Time.every Time.second <tagger>`. To describe this behavior in your test, you\ncould do the following:\n\n    let\n      fakeSub = Elmer.Spy.create \"fake-time\" (\\_ -> Time.every)\n        |> Elmer.Spy.andCallFake (\\interval tagger ->\n          Elmer.Subscription.fake \"everySecond\" tagger\n        )\n    in\n      testState\n        |> Spy.use [ fakeSub ]\n        |> with (\\() -> MyModule.subscriptions)\n        |> send \"everySecond\" (Time.millisToPosix 3000)\n        |> target\n            << by [ id \"current-time\" ]\n        |> Elmer.Html.expect (element <|\n            hasText \"3 seconds\"\n          )\n\n",
        "type": "(() -> model -> Platform.Sub.Sub msg) -> Elmer.TestState model msg -> Elmer.TestState model msg"
      }
    ],
    "binops": []
  }
]