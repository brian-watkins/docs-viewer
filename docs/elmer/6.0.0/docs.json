[{"name":"Elmer","comment":" Basic types and functions for working with tests and matchers.\n\n@docs TestState\n\n# Working with Matchers\n@docs Matcher, expectAll, expectNot\n\n# List Matchers\n@docs each, exactly, some, atIndex, last, hasLength\n\n# Make low-level expectations\n@docs given, expectModel\n\n# Resolve Deferred Commands and Tasks\n@docs resolveDeferred\n\n","unions":[],"aliases":[{"name":"Matcher","comment":" Generic type for functions that pass or fail.\n\nA matcher returns an `Expect.Expectation` from the\n[elm-test](https://package.elm-lang.org/packages/elm-explorations/test/latest)\npackage.\n","args":["a"],"type":"a -> Expect.Expectation"},{"name":"TestState","comment":" Represents the current state of the test.\n","args":["model","msg"],"type":"Elmer.TestState.TestState model msg"}],"values":[{"name":"atIndex","comment":" Expect that the item at the given index satisfies the given matcher.\n","type":"Basics.Int -> Elmer.Matcher a -> Elmer.Matcher (List.List a)"},{"name":"each","comment":" Expect that all items in a list satisfy the given matcher.\n","type":"Elmer.Matcher a -> Elmer.Matcher (List.List a)"},{"name":"exactly","comment":" Expect that exactly some number of items in a list satisfy the given matcher.\n","type":"Basics.Int -> Elmer.Matcher a -> Elmer.Matcher (List.List a)"},{"name":"expectAll","comment":" Expect that all matchers pass.\nIf one fails, then the conjoined matcher fails, otherwise it passes.\n\n    Elmer.given someModel view update\n      |> Elmer.Html.expect (\n        Elmer.Html.Matchers.element <|\n          Elmer.Html.expectAll\n            [ Elmer.Html.Matchers.hasText \"Awesome\"\n            , Elmer.Html.Matchers.hasClass \"cool\"\n            ]\n        )\n","type":"List.List (Elmer.Matcher a) -> Elmer.Matcher a"},{"name":"expectModel","comment":" Make expectations about the model in its current state.\n\n    Elmer.given defaultModel view update\n      |> Elmer.Html.target \"button\"\n      |> Elmer.Html.Event.click\n      |> Elmer.expectModel (\\model ->\n        Expect.equal model.clickCount 1\n      )\n\nUse Elmer to get the model into a certain state. Then use the normal facilities of\nelm-test to describe how the model should look in that state.\n","type":"Elmer.Matcher model -> Elmer.Matcher (Elmer.TestState model msg)"},{"name":"expectNot","comment":" Expect that a matcher fails.\n","type":"Elmer.Matcher a -> Elmer.Matcher a"},{"name":"given","comment":" Initialize a test with a model, view function, and update function.\n","type":"model -> (model -> Html.Html msg) -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"},{"name":"hasLength","comment":" Expect that a list has the given length.\n","type":"Basics.Int -> Elmer.Matcher (List.List a)"},{"name":"last","comment":" Expect that the last item in a list satisfies the given matcher.\n","type":"Elmer.Matcher a -> Elmer.Matcher (List.List a)"},{"name":"resolveDeferred","comment":" Resolve any deferred commands or tasks.\n\nOnce this function is called, all messages associated with deferred commands or tasks will be\nsent to the `update` function.\n\nYou can defer processing of a `Cmd` or `Task` using `Elmer.Command.defer` or `Elmer.Task.defer`, respectively.\n\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"some","comment":" Expect that at least one item in a list satisfies the given matcher.\n","type":"Elmer.Matcher a -> Elmer.Matcher (List.List a)"}],"binops":[]},{"name":"Elmer.Command","comment":" Functions for dealing with commands during your tests.\n\nElmer allows you to manage the effects of commands yourself, so you can\ndescribe the behavior of a component under whatever conditions you need.\n\nTo manage the effects of a command, you'll need to do two things.\n\n1. Stub the function in your code that produces the command and replace\nit with a function that returns one of the fake commands described below.\n\n2. Enjoy.\n\nNote: Elmer supports `Platform.Cmd.batch` and `Platform.Cmd.map` so you can use these in your\ncomponent as expected.\n\nNote: Elmer provides special support for commands generated by\n[elm/http](http://package.elm-lang.org/packages/elm/http/latest)\nand [elm/browser](https://package.elm-lang.org/packages/elm/browser/latest/Browser-Navigation)\n-- See `Elmer.Http` and `Elmer.Navigation`, respectively.\n\n# Fake Commands\n@docs fake, dummy, expectDummy, fail\n\n# Defer a Command\n@docs defer\n\n# Send a Fake Command\n@docs send\n\n# Test a Command\n@docs given, expectMessages\n\n","unions":[],"aliases":[],"values":[{"name":"defer","comment":" Defer a command for later processing.\n\nYou might want to describe the behavior that occurs after a command\nis sent but before its effect is processed -- for example, the component could\nindicate that network activity is occurring while waiting for a request to complete.\n\nWhen a deferred command is processed, any effect associated with that command will *not* be sent\nto the component's `update` function until `Elmer.resolveDeferred` is called.\n","type":"Platform.Cmd.Cmd msg -> Platform.Cmd.Cmd msg"},{"name":"dummy","comment":" Generate a dummy command.\n\nYou might only care to describe the fact that a command has been sent, and not\nthe behavior that may result from its effect. In that case, use a dummy command.\n\nWhen this command is processed, the fact that it occured will be\nrecorded; no message will be passed to the component's `update` function.\nThis will be most useful in conjunction with `expectDummy`.\n","type":"String.String -> Platform.Cmd.Cmd msg"},{"name":"expectDummy","comment":" Expect that a dummy command with the given identifier has been sent.\n","type":"String.String -> Elmer.Matcher (Elmer.TestState model msg)"},{"name":"expectMessages","comment":" Make expectations about messages generated by processing a command.\n\n    Elmer.Command.given (\\() -> \n        MyModule.commandToSendAnHttpRequest someArg\n    )\n      |> Elmer.Spy.use \n          [ Elmer.Http.serve [ someStubbedResponse ] ]\n      |> Elmer.expectMessages (\n        exactly 1 <| Expect.equal (\n          MyMessage <| \n            Ok \"response from server\"\n        )\n      )\n\nNote that `expectMessages` should only be used in a test initialized\nwith `Elmer.Command.given`.\n","type":"Elmer.Matcher (List.List msg) -> Elmer.Matcher (Elmer.TestState.TestState () msg)"},{"name":"fail","comment":" Generate a command that will cause the test to fail with the specified message.\n","type":"String.String -> Platform.Cmd.Cmd msg"},{"name":"fake","comment":" Generate a command that returns a message.\n\nWhen this command is processed, the message will be passed\nto the component's `update` function.\n","type":"msg -> Platform.Cmd.Cmd msg"},{"name":"given","comment":" Initialize a `TestState` with a command.\n\nA test initialized in this way can use `expectMessages` to examine\nmessages generated when the given command is processed.\n","type":"(() -> Platform.Cmd.Cmd msg) -> Elmer.TestState.TestState () msg"},{"name":"send","comment":" Send a command.\n\nUse this function to send a command to your program. Any effect associated with this\ncommand will be processed accordingly. Elmer only knows how to process the fake commands\ndescribed above.\n\nThe first argument is a function that returns the command to be sent.\nWe do this to allow Elmer to evaluate the command-generating function lazily,\nin case any stubbed functions need to be applied.\n\n    testState\n      |> send (\\() -> \n          MyModule.generateSomeCommand\n        )\n      |> Elmer.Html.target \n          << by [ class \"some-class\" ]\n      |> Elmer.Html.expect \n          Elmer.Html.Matchers.elementExists\n\n","type":"(() -> Platform.Cmd.Cmd msg) -> Elmer.TestState model msg -> Elmer.TestState model msg"}],"binops":[]},{"name":"Elmer.Effects","comment":" Functions for working with effects during a test.\n\nFunctions that return `Cmd` values to the Elm runtime may have side effects that you\nwant to track during a test. For instance, the `Elmer.Http` module will keep track of \nrequests that would be sent when the Elm runtime processes a given command so you can\nmake expectations about them later.\n\nNote that these functions are mainly useful when writing extensions to Elmer\nor custom matchers.\n\n# Record Effects\n@docs push, pushWithTask\n\n# Working with Effects\n@docs expect, use\n\n","unions":[],"aliases":[],"values":[{"name":"expect","comment":" Make an expectation about stored effects.\n\n    testState\n      |> Command.send (\\_ -> push Effects (\\_ -> \"Hello!\"))\n      |> expect Effects (\\maybeEffect ->\n        Maybe.withDefault \"\" maybeEffect\n          |> Expect.equal \"Hello!\"\n      )\n\n","type":"effectId -> (Maybe.Maybe a -> Expect.Expectation) -> Elmer.TestState.TestState model msg -> Expect.Expectation"},{"name":"push","comment":" Create a command that records an effect. \n\nProvide a custom type as an 'effectId' and then a function that produces the\nnew value for the stored effects based on what has (or has not) been stored already.\n\nThis function produces a command that should be sent to the Elmer runtime, either in\nthe normal course of code that's been exercised or via `Elmer.Command.send`. \n\nFor example, suppose you have an effect id like:\n\n    type Effects =\n      Effects\n\nYou could record effects like so:\n\n    testState\n      |> Command.send (\\_ -> push Effects (\\_ -> \"Hello!\"))\n\n","type":"effectId -> (Maybe.Maybe a -> a) -> Platform.Cmd.Cmd msg"},{"name":"pushWithTask","comment":" Create a task that records an effect when the given task is processed.\n","type":"effectId -> (Maybe.Maybe a -> a) -> Task.Task x b -> Task.Task x b"},{"name":"use","comment":" Use a recorded effect during a test.\n\nThis function allows you to access the currently recorded effects during a test to produce\nfurther steps in that test. For example, if your test stored a list of effects with the id `Effects`\nthen you could clear that list like so:\n\n    testState\n      |> use Effects (\\_ state ->\n        state\n          |> Command.send (\\_ -> Effects.push Effects (\\_ -> []))\n      )\n\n","type":"effectId -> (Maybe.Maybe a -> Elmer.TestState.TestState model msg -> Elmer.TestState.TestState model msg) -> Elmer.TestState.TestState model msg -> Elmer.TestState.TestState model msg"}],"binops":[]},{"name":"Elmer.Html","comment":" Functions for working with the `Html msg` generated by the component's view function.\n\n# Target Html Elements\n@docs HtmlTarget, HtmlElement, HtmlSelector, HtmlSelectorGroup, target\n\n# Make Expectations\n@docs expect\n\n# Render the View\n@docs render\n\n","unions":[],"aliases":[{"name":"HtmlElement","comment":" Represents an Html element.\n","args":["msg"],"type":"Elmer.Html.Types.HtmlElement msg"},{"name":"HtmlSelector","comment":" Represents a function for matching an Html Element.\n\nYou can create your own `HtmlSelector`. For example, here's \nan `HtmlSelector` that matches any element that has at least one\nof the given classes:\n\n    classOf : List String -> HtmlSelector msg\n    classOf expectedClasses element =\n      { description = \n          \"one of \" ++ \n            String.join \",\" expectedClasses\n      , predicate = \n          \\element ->\n            Element.classList element\n              |> List.filter (\\c -> \n                  List.member c expectedClasses\n                )\n              |> not << List.isEmpty\n      }\n\nwhich you could use to target elements that have either the class `funny` or `awesome`\nlike so:\n\n    Elmer.Html.target \n      << by [ classOf [ \"funny\", \"awesome\" ] ]\n","args":["msg"],"type":"{ description : String.String, predicate : Elmer.Html.HtmlElement msg -> Basics.Bool }"},{"name":"HtmlSelectorGroup","comment":" Represents a group of `HtmlSelector` used to match an Html Element.\n","args":["msg"],"type":"Elmer.Html.Types.HtmlSelectorGroup msg"},{"name":"HtmlTarget","comment":" Represents the Html Element or Elements about which expectations will be made.\n\nAn `HtmlTarget` is determined by the last use of `Elmer.Html.target`.\n","args":["msg"],"type":"Elmer.Html.Types.HtmlTarget msg"}],"values":[{"name":"expect","comment":" Make expectations about the targeted html.\n\n    testState\n      |> target << by [ class \"my-class\" ]\n      |> expect (\n        Elmer.Html.Matchers.element <|\n          Elmer.Html.Matchers.hasText \"some text\"\n      )\n\nUse `expect` in conjunction with matchers like `element`, `elementExists`,\nor `elements`.\n","type":"Elmer.Matcher (Elmer.Html.HtmlTarget msg) -> Elmer.Matcher (Elmer.TestState model msg)"},{"name":"render","comment":" Call the component's view function with the current model.\n\nSometimes, it may be useful to render the component's view manually. For example,\nif you are spying on some function called by the view function, you'll need to\nrender the view manually before you can make expectations about that spy.\n\nNote: Usually you will not need to render the view manually.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"target","comment":" Target an element or elements within the Html produced by the\ncomponent's `view` function.\n\nUse this function to specify which element will receive an event or which should\nbe the subject of any expectations.\n\nSee `Elmer.Html.Selector` for some common selectors. For example, to target\na `div` that has a class `.some-class` and is a child of a `li` whose ancestor is an\nelement with `root` as the value of its `id` attribute:\n\n    target \n      << descendantsOf [ id \"root\" ]\n      << childrenOf [ tag \"li\" ]\n      << by [ tag \"div\", class \"some-class\" ]\n\nYou can chain as many `Elmer.Html.Selector.descendantsOf` or `Elmer.Html.Selector.childrenOf` calls\nas you like; the chain must end with a call to `Elmer.Html.Selector.by`.\n","type":"( Elmer.Html.HtmlSelectorGroup msg, Elmer.TestState model msg ) -> Elmer.TestState model msg"}],"binops":[]},{"name":"Elmer.Html.Element","comment":" Functions for working directly with HtmlElements.\n\n# Element Characteristics\n@docs tag, id, classList, styles, property, boolProperty, properties, attributes, texts, children\n\n# Target Descendants\n@docs target\n\n# Debugging\n@docs toString\n\n","unions":[],"aliases":[],"values":[{"name":"attributes","comment":" Get this element's attributes as a `Dict`. If you define a custom attribute\nfor an Html element, you can find it with this function.\n\n    Elmer.given someModel view update\n      |> target << by [ id \"some-element\" ]\n      |> expect (element <| \\element ->\n        attributes element\n          |> Dict.get \"data-attribute\"\n          |> Expect.notEqual Nothing\n      )\n","type":"Elmer.Html.HtmlElement msg -> Dict.Dict String.String String.String"},{"name":"boolProperty","comment":" Get the boolean value of a particular property belonging to\nthis element, if that property is defined.\n\nIf the property is defined, but its value is not boolean, then\n`Nothing` is returned.\n","type":"String.String -> Elmer.Html.HtmlElement msg -> Maybe.Maybe Basics.Bool"},{"name":"children","comment":" Get the Html elements that are children of this element.\n\nNote that `Html.text` values are excluded. Use `texts` to get those.\n","type":"Elmer.Html.HtmlElement msg -> List.List (Elmer.Html.HtmlElement msg)"},{"name":"classList","comment":" Get a list of classes applied to this element.\n","type":"Elmer.Html.HtmlElement msg -> List.List String.String"},{"name":"id","comment":" Get the value of the element's `id` attribute, if it is defined.\n","type":"Elmer.Html.HtmlElement msg -> Maybe.Maybe String.String"},{"name":"properties","comment":" Get this element's properties as a `Dict`.\n\nOn the difference between attributes and properties,\nsee [this](https://github.com/elm/html/blob/master/properties-vs-attributes.md).\n","type":"Elmer.Html.HtmlElement msg -> Dict.Dict String.String String.String"},{"name":"property","comment":" Get the value of a particular property belonging to this\nelement, if that property is defined.\n","type":"String.String -> Elmer.Html.HtmlElement msg -> Maybe.Maybe String.String"},{"name":"styles","comment":" Get this element's styles as a `Dict`.\n","type":"Elmer.Html.HtmlElement msg -> Dict.Dict String.String String.String"},{"name":"tag","comment":" Get the tag of the element\n","type":"Elmer.Html.HtmlElement msg -> String.String"},{"name":"target","comment":" Target descendants of an element.\n\nUse this function in conjunction with `HtmlTarget` matchers like `element` or `elements`\nto make expectations about descendants of an element.\n\n    Elmer.given someModel view update\n      |> Elmer.Html.target\n          << by [ id \"some-element\" ]\n      |> Elmer.Html.expect (Elmer.Html.Matchers.element <|\n          \\element ->\n            element\n              |> target << by [ tag \"div\" ]\n              |> Elmer.Html.Matchers.elements (\n                Elmer.hasLength 3\n              )\n        )\n\nNote that `Elmer.Html.target << descendantsOf [ id \"some-element\" ] << by [ tag \"div\" ]` would allow you to write the\nsame expectation. Use `Element.target` for complex expectations about nested elements.\n\n","type":"( Elmer.Html.Types.HtmlSelectorGroup msg, Elmer.Html.HtmlElement msg ) -> Elmer.Html.HtmlTarget msg"},{"name":"texts","comment":" Get the `Html.text` values that are children of this element.\n","type":"Elmer.Html.HtmlElement msg -> List.List String.String"},{"name":"toString","comment":" Represent an `HtmlElement` as a String.\n","type":"Elmer.Html.HtmlElement msg -> String.String"}],"binops":[]},{"name":"Elmer.Html.Event","comment":" Trigger events on targeted elements. When an event occurs, Elmer will\ncall the component's `update` method with the resulting message.\n\nElmer respects the `stopPropagation` option on event handlers. An event on an\nelement will bubble up through that element's ancestors until an event handler\nsays otherwise.\n\nThis means, for example, that you can `click` a targeted element whose\nancestor registers for click events and the event will be handled by that\nancestor as expected.\n\nThe `mouseEnter` and `mouseLeave` events are exceptions to this rule. These events only\ntrigger a handler attached to the targeted element. See `moveMouseIn` and `moveMouseOut`\nfor more.\n\n# Mouse Events\n\nAll mouse events occur at a simulated position of `{ pageX = 0, pageY = 0}`. If your\ntest needs a mouse event to occur at a specific position, use `trigger`.\n\n@docs click, doubleClick, press, release, moveMouseIn, moveMouseOut\n\n# Form Events\n@docs input, check, uncheck, select\n\n# Focus Events\n@docs focus, blur\n\n# Custom Events\n@docs trigger\n\n","unions":[],"aliases":[],"values":[{"name":"blur","comment":" Trigger a blur event on the targeted element.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"check","comment":" Trigger a change event on the targeted checkbox element with\n`True` for the `checked` property.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"click","comment":" Simulate a click on the targeted element.\n\nA click will trigger the appropriate `click`, `mouseDown`, and `mouseUp` event\nhandlers on the targeted element or its ancestors.\n\nA click on an input element with type submit or a button element with type submit (or\na button with no type specified) will also trigger the appropriate `submit` event handlers as follows:\n- If the targeted element has a form attribute, then the submit handler\non the specified form will be triggered; if the specified form does not exist, no submit\nhandlers will be triggered.\n- If the targeted element has no form attribute, then the submit handler on any form that is an\nancestor of the targeted element will be triggered.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"doubleClick","comment":" Simulate a double click on the targeted element.\n\nTwo clicks will occur in succession, with the second also triggering a double\nclick event. See `click` above for a list of the events triggered by a click.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"focus","comment":" Trigger a focus event on the targeted element.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"input","comment":" Trigger an input event on the targeted element.\n","type":"String.String -> Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"moveMouseIn","comment":" Simulate moving the mouse into the targeted element.\n\nThis may trigger any relevant `mouseOver` or `mouseEnter` event handlers.\n\nNote: Mouse enter events do not propagate, so a mouse enter action will only\ntrigger an event handler that is registered by the targeted element.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"moveMouseOut","comment":" Simulate moving the mouse out of the targeted element.\n\nThis may trigger any relevant `mouseOut` or `mouseLeave` event handlers.\n\nNote: Mouse leave events do not propagate, so a mouse leave action will only\ntrigger an event handler that is registered by the targeted element.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"press","comment":" Trigger a mouse down event on the targeted element.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"release","comment":" Trigger a mouse up event on the targeted element.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"select","comment":" Trigger an input event on the targeted select element.\n\nThe argument specifies the option to select by its `value` property.\n","type":"String.String -> Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"trigger","comment":" Trigger a custom event on the targeted element. Provide the name of the event\nand the proper representation of the event object in JSON format.\n\nThe following will trigger a `keyup` event:\n\n    testState\n      |> trigger \"keyup\" \"{\\\"keyCode\\\":65}\"\n","type":"String.String -> String.String -> Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"uncheck","comment":" Trigger a change event on the targeted checkbox element with\n`False` for the `checked` property.\n","type":"Elmer.TestState model msg -> Elmer.TestState model msg"}],"binops":[]},{"name":"Elmer.Html.Matchers","comment":" Make expectations about the Html generated by a view function.\n\n# HtmlTarget Matchers\n@docs element, elementExists, elements\n\n# HtmlElement Matchers\n@docs hasText, hasId, hasClass, hasStyle, hasAttribute, listensForEvent\n\n","unions":[],"aliases":[],"values":[{"name":"element","comment":" Make expectations about the selected element.\n\nThe matcher will fail if the selected element does not exist.\n\nIf the selector matches more than one element,\nthe given element matcher will only be applied to the first element selected.\n\n    testState\n      |> Elmer.Html.target \n          << by [ tag \"div\" ]\n      |> Elmer.Html.expect (\n          element <| hasText \"Fun Stuff\"\n        )\n\n","type":"Elmer.Matcher (Elmer.Html.HtmlElement msg) -> Elmer.Matcher (Elmer.Html.HtmlTarget msg)"},{"name":"elementExists","comment":" Expect that the selected element exists.\n\n    testState\n      |> Elmer.Html.target \n          << by [ id \"cool-element\" ]\n      |> Elmer.Html.expect elementExists\n","type":"Elmer.Matcher (Elmer.Html.HtmlTarget msg)"},{"name":"elements","comment":" Make expectations about the selected elements.\n\nIf the selector fails to match any elements, an empty list will\nbe passed to the given matcher.\n\n    testState\n      |> Elmer.Html.target \n          << by [ tag \"li\" ]\n      |> Elmer.Html.expect (\n          elements <| Elmer.hasLength 4\n        )\n","type":"Elmer.Matcher (List.List (Elmer.Html.HtmlElement msg)) -> Elmer.Matcher (Elmer.Html.HtmlTarget msg)"},{"name":"hasAttribute","comment":" Expect that an element has the specified attribute or property with the specified value.\n\n    testState\n      |> Elmer.Html.target\n          << by [ id \"fun-element\" ]\n      |> Elmer.Html.expect (element <|\n          hasAttribute ( \"src\", \"http://fun.com\" )\n        )\n\nOn the difference between attributes and properties,\nsee [this](https://github.com/elm-lang/html/blob/master/properties-vs-attributes.md).\n","type":"( String.String, String.String ) -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"},{"name":"hasClass","comment":" Expect that an element has the specified class. No need to prepend the class name with a dot.\n","type":"String.String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"},{"name":"hasId","comment":" Expect that an element has the specified id. No need to prepend the id with a pound sign.\n","type":"String.String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"},{"name":"hasStyle","comment":" Expect that an element has the specified style.\n\n    hasStyle (\"left\", \"20px\") element\n\n","type":"( String.String, String.String ) -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"},{"name":"hasText","comment":" Expect that an element has some text. This matcher will pass only if the element\nor any of its descendents contains some `Html.text` with the specified text.\n","type":"String.String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"},{"name":"listensForEvent","comment":" Expect that an element listens for an event of the given type.\n\n    testState\n      |> Elmer.Html.target\n          << by [ id \"fun-element\" ]\n      |> Elmer.Html.expect (element <|\n          listensForEvent \"click\"\n        )\n\nNote: This will not consider event handlers on the element's ancestors.\n","type":"String.String -> Elmer.Matcher (Elmer.Html.HtmlElement msg)"}],"binops":[]},{"name":"Elmer.Html.Selector","comment":" Functions for selecting Html elements to be targeted during a test.\n\n# Basic Selectors\n@docs id, tag, class, attribute, attributeName, text\n\n# Group Selectors\n@docs by, descendantsOf, childrenOf\n\n","unions":[],"aliases":[],"values":[{"name":"attribute","comment":" Select Html elements that have an attribute or property with the given name and value.\n\nOn the difference between attributes and properties,\nsee [this](https://github.com/elm-lang/html/blob/master/properties-vs-attributes.md).\n","type":"( String.String, String.String ) -> Elmer.Html.HtmlSelector msg"},{"name":"attributeName","comment":" Select Html elements that have an attribute or proprty with the given name, regardless of the associated value.\n\nOn the difference between attributes and properties,\nsee [this](https://github.com/elm-lang/html/blob/master/properties-vs-attributes.md).\n","type":"String.String -> Elmer.Html.HtmlSelector msg"},{"name":"by","comment":" Select Html elements that match all the given selectors.\n\nThis would select all `div` elements that have the class `some-class`:\n\n    testState\n      |> Elmer.Html.target\n          << by [ tag \"div\", class \"some-class\" ]\n","type":"List.List (Elmer.Html.HtmlSelector msg) -> targetable -> ( Elmer.Html.HtmlSelectorGroup msg, targetable )"},{"name":"childrenOf","comment":" Narrow the scope of further selections to those elements that are children of the selected elements.\n\nSuppose you want to select all `li` that are children of an `ol`:\n\n    testState\n      |> Elmer.Html.target\n        << childrenOf [ tag \"ol\" ]\n        << by [ tag \"li\" ]\n","type":"List.List (Elmer.Html.HtmlSelector msg) -> ( Elmer.Html.HtmlSelectorGroup msg, targetable ) -> ( Elmer.Html.HtmlSelectorGroup msg, targetable )"},{"name":"class","comment":" Select Html elements by css class. \n","type":"String.String -> Elmer.Html.HtmlSelector msg"},{"name":"descendantsOf","comment":" Narrow the scope of further selections to descendants of the selected elements.\n\nSuppose you want to select all `li` that are descendants of an `ol` that is itself a descendant of\nan element with a particular class:\n\n    testState\n      |> Elmer.Html.target\n        << descendantsOf [ class \"some-class\" ]\n        << descendantsOf [ tag \"ol\" ]\n        << by [ tag \"li\" ]\n\nYou can chain as many `descendantsOf` calls as you like, but the chain must be terminated with a call to `by`.\n","type":"List.List (Elmer.Html.HtmlSelector msg) -> ( Elmer.Html.HtmlSelectorGroup msg, targetable ) -> ( Elmer.Html.HtmlSelectorGroup msg, targetable )"},{"name":"id","comment":" Select Html elements by id.\n","type":"String.String -> Elmer.Html.HtmlSelector msg"},{"name":"tag","comment":" Select Html elements by tag name.\n","type":"String.String -> Elmer.Html.HtmlSelector msg"},{"name":"text","comment":" Select Html elements that have the given text as an immediate descendant.\n\nFor example,\n\n    testState\n      |> target << by [ text \"Some text\" ]\n\nwould select only the `p` element in the following:\n\n    Html.div []\n    [ Html.p [] [ Html.text \"Some text\" ]\n    ]\n\n","type":"String.String -> Elmer.Html.HtmlSelector msg"}],"binops":[]},{"name":"Elmer.Message","comment":" Functions for producing messages that explain why a test has failed.\n\nNote that these functions are mainly useful when writing extensions to Elmer\nor custom matchers.\n\n@docs Message, note, fact, format\n\n","unions":[{"name":"Message","comment":" Represents a message explaining why a test has failed.\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"fact","comment":" Produce a message that consists in a description of the failure\nplus details about what exactly failed or why.\n\n    [ fact \"Expected\" \"something\"\n    , fact \"to equal\" \"nothing\"\n    ]\n      |> Message.format\n\nwill produce text that looks something like:\n\n    Expected\n      \n      something\n    \n    to equal\n    \n      nothing\n\n","type":"String.String -> String.String -> Elmer.Message.Message"},{"name":"format","comment":" Produce a string from a list of messages.\n\n    [ fact \"Expected\" \"something\"\n    , fact \"to equal\" \"nothing\"\n    , note \"but it does not.\"\n    ]\n      |> Message.format\n\nwill produce text that looks something like:\n\n    Expected\n      \n      something\n    \n    to equal\n    \n      nothing\n\n    but it does not.\n\n","type":"List.List Elmer.Message.Message -> String.String"},{"name":"note","comment":" Produce a message that consists in one line of text.\n\n","type":"String.String -> Elmer.Message.Message"}],"binops":[]},{"name":"Elmer.Message.Failure","comment":" Format a test failure reason from\nthe [elm-explorations/test](https://package.elm-lang.org/packages/elm-explorations/test/latest/)\npackage.\n\nNote that these functions are mainly useful when writing extensions to Elmer\nor custom matchers.\n\n@docs Failure, format\n\n","unions":[],"aliases":[{"name":"Failure","comment":" Represents a failure reason from the\n[elm-explorations/test](https://package.elm-lang.org/packages/elm-explorations/test/latest/) package.\n\nYou can obtain a failure reason with `Test.Runner.getFailureReason`.\n\nSee [the elm-explorations/test docs](https://package.elm-lang.org/packages/elm-explorations/test/latest/Test-Runner#getFailureReason)\nfor more information.\n\n","args":[],"type":"{ given : Maybe.Maybe String.String, description : String.String, reason : Test.Runner.Failure.Reason }"}],"values":[{"name":"format","comment":" Format a list of `Failure` values as a string.\n","type":"List.List Elmer.Message.Failure.Failure -> String.String"}],"binops":[]},{"name":"Elmer.Navigation","comment":" Functions for describing the navigation behavior of Elm Html programs created with `Browser.application`.\n\n# Make Expectations about the Current Location\n@docs spy, expectLocation\n\n# Get a Fake Navigation Key\n@docs fakeKey\n\n","unions":[],"aliases":[],"values":[{"name":"expectLocation","comment":" Expect that the current location is equal to the given string.\n\nThis expectation must be used in conjunction with `spy` above, and your `TestState` must be \ncreated with `Elmer.Program.givenApplication`. \n\nSuppose your app calls `Browser.Navigation.pushUrl` when an element is clicked. You can describe\nthis behavior as follows: \n\n    Elmer.Program.givenApplication App.OnUrlRequest App.OnUrlChange App.view App.update\n      |> Elmer.Spy.use [ Elmer.Navigation.spy ]\n      |> Elmer.Program.init (\\_ -> \n          App.init testFlags testUrl Elmer.Navigation.fakeKey\n        )\n      |> Elmer.Html.target\n          << by [ id \"some-element\" ]\n      |> Elmer.Html.Event.click\n      |> Elmer.Navigation.expectLocation\n          \"http://mydomain.com/funStuff.html\"\n\nNote that `expectLocation` will only match on urls provided via `Browser.Navigation.pushUrl` or\n`Browser.Navigation.replaceUrl`. In particular, `expectLocation` will not match the url provided\nas part of the call to `Elmer.init` that provides the initial model and command values. \n","type":"String.String -> Elmer.Matcher (Elmer.TestState model msg)"},{"name":"fakeKey","comment":" Generate a fake `Browser.Navigation.Key` value.\n\nUse this value when calling the init function of a `Browser.application` program during a test.\n","type":"Browser.Navigation.Key"},{"name":"spy","comment":" Stub `Browser.Navigation.pushUrl` and `Browser.Navigation.replaceUrl` with a function that\nrecords the location as it is set.\n\nYou must use this function with `Elmer.Spy.use` in order to make expectations\nabout the location.\n\nSuppose you want to test a home button that sets the\nlocation to `/home` when clicked:\n\n    testState\n      |> Spy.use [ Navigation.spy ]\n      |> Elmer.Html.target \n          << by [ id \"home-button\" ]\n      |> Elmer.Html.Event.click\n      |> Elmer.Navigation.expectLocation \"/home\"\n\n","type":"Elmer.Spy.Spy"}],"binops":[]},{"name":"Elmer.Program","comment":" Functions for working with Elm programs.\n\n# Test an Elm Html Sandbox or Element Program\n@docs givenElement\n\n# Test an Elm Html Application\n@docs givenApplication\n\n# Test an Elm Html Document\n@docs givenDocument\n\n# Test am Elm Worker Program\n@docs givenWorker\n\n# Initialize an Elm program\n@docs init\n\n","unions":[],"aliases":[],"values":[{"name":"givenApplication","comment":" Initialize a `TestState` with the basic requirements for a program\ncreated with `Browser.application`. \n\nThe arguments are:\n\n1. Function that maps a new `Browser.UrlRequest` to a `msg`\n2. Function that maps a `Url` to a `msg` when the url changes\n3. View function that results in a `Browser.Document`\n4. Update function\n\nYou'll need to call `Elmer.Program.init` with the program's `init` function to properly\nstart your test.\n","type":"(Browser.UrlRequest -> msg) -> (Url.Url -> msg) -> (model -> Browser.Document msg) -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"},{"name":"givenDocument","comment":" Initialize a `TestState` with the basic requirements for a program\ncreated with `Browser.document`.\n\nThe arguments are:\n\n1. View function that results in a `Browser.Document`\n2. Update function.\n\nYou'll need to call `Elmer.Program.init` with the program's `init` function to properly\nstart your test.\n","type":"(model -> Browser.Document msg) -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"},{"name":"givenElement","comment":" Initialize a `TestState` with the basic requirements for a program created with\n`Browser.sandbox` or `Browser.element`.\n\nThe arguments are:\n\n1. View function\n2. Update function\n\nYou'll need to call `Elmer.Program.init` with the program's `init` function to properly\nstart your test.\n","type":"(model -> Html.Html msg) -> (msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"},{"name":"givenWorker","comment":" Initialize a `TestState` with the basic requirements for\na headless worker program created with `Platform.worker`.\n\nThe argument is an update function.\n\nYou'll need to call `Elmer.Program.init` with the program's `init` function to properly\nstart your test.\n","type":"(msg -> model -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg"},{"name":"init","comment":" Update the test context with the given model and Cmd.\n\nProvide a function that calls a program's `init` function and returns a model and a command. \nThe resuling model will become the current model for the system under test and the given command\nwill be executed. \n\n    Elmer.Program.givenDocument MyDocument.view MyDocument.update\n      |> init (\\() -> MyDocument.init)\n      |> Elmer.Html.target\n          << by [ id \"title\" ]\n      |> Elmer.Html.expectElementExists\n\nNote: If your test requires any spies, call `Spy.use` before your call to `init` so the spies will\nbe available whan the supplied function is evaluated.\n","type":"(() -> ( model, Platform.Cmd.Cmd msg )) -> Elmer.TestState model msg -> Elmer.TestState model msg"}],"binops":[]},{"name":"Elmer.Program.Matchers","comment":" Make expectations about the Document generated by a view function.\n\n# Document Matchers\n@docs expectTitle\n\n","unions":[],"aliases":[],"values":[{"name":"expectTitle","comment":" Expect that a document has some title.\n","type":"String.String -> Elmer.Matcher (Elmer.TestState model msg)"}],"binops":[]},{"name":"Elmer.Spy","comment":" Functions for spying during tests.\n\n@docs Spy, Calls, batch\n\n# Spy on a Function\n@docs SpyReference, observe, andCallThrough, andCallFake, replaceValue\n\n# Use a Spy\n@docs inject, use\n\n# Make Expectations about a Spy\n@docs expect\n\n","unions":[{"name":"SpyReference","comment":" Represents a real function to spy on.\n","args":["a","b"],"cases":[]}],"aliases":[{"name":"Calls","comment":" Represents the calls made to a spy.\n","args":[],"type":"Elmer.Spy.Internal.Calls"},{"name":"Spy","comment":" Represents a function that has been spied on.\n","args":[],"type":"Elmer.Spy.Internal.Spy"}],"values":[{"name":"andCallFake","comment":" Call the provided function when a spied-upon function is called.\n\nOnce you're observing a function, you can provide a fake implementation like so:\n\n    mySpy =\n      Elmer.Spy.observe (\\_ ->\n        MyModule.someFunction\n      )\n      |> andCallFake testImplementation\n\nwhere `testImplementation` is some function with the very same signature as\nthe one being spied upon.\n\nIf you are spying on a function that returns a `Cmd`, then your fake\nshould return `Cmd.none` or one of the fake commands described in `Elmer.Command`.\n\nFor example, you could override `Random.generate` so that it returns a set value during a test\nlike so:\n\n    Elmer.Spy.observe (\\_ ->\n      Random.generate\n    )\n    |> Elmer.Spy.andCallFake (\\tagger generator ->\n      Random.initialeSeed 10001\n        |> Random.step generator\n        |> tagger\n        |> Elmer.Command.fake\n    )\n\nIf you are spying on a function that returns a `Sub`, then your fake should\nreturn a fake subscription; see `Elmer.Subscription.fake`.\n\nNote: The fake implementation will not be active until you register this spy\nvia `Elmer.Spy.use`.\n","type":"(a -> b) -> Elmer.Spy.SpyReference a b -> Elmer.Spy.Spy"},{"name":"andCallThrough","comment":" Call through to the existing implementation of a spied-upon function.\n\nOnce you're observing a function, you can just call `andCallThrough` to have Elmer call the original\nimplementation whenever the function is called. \n\n    mySpy =\n      Elmer.Spy.observe (\\_ ->\n        MyModule.someFunction\n      )\n      |> andCallThrough\n\nUse `andCallThrough` when you want to examine the arguments passed to a function and don't need to \nchange what that function does for your tests.\n\nNote: The Spy will not be active until you register it via `Elmer.Spy.use`.\n","type":"Elmer.Spy.SpyReference a b -> Elmer.Spy.Spy"},{"name":"batch","comment":" Combine multiple `Spy` values into one.\n","type":"List.List Elmer.Spy.Spy -> Elmer.Spy.Spy"},{"name":"expect","comment":" Make an expectation about a spy.\n\nSee `Elmer.Spy.Matchers` for matchers to use with this function.\n\n    let\n      mySpy =\n        Elmer.Spy.observe (\\_ -> \n          MyModule.someFunction\n        )\n        |> andCallThrough\n    in\n      testState\n        |> use [ mySpy ]\n        |> expect (\\_ -> MyModule.someFunction) (\n          wasCalled 0\n        )\n","type":"(() -> a -> b) -> Elmer.Matcher Elmer.Spy.Calls -> Elmer.TestState model msg -> Expect.Expectation"},{"name":"inject","comment":" Provide a function you want to spy on to the subject under test.\n\nSometimes, you might want to provide a fake version of some dependency\nto the subject under test. If you also want to spy on that fake dependency\nthen you will need to do three things. First, create that fake\nfunction in your test module. Second, use `Elmer.Spy.inject` to provide the function\nto the subject under test. Third, create and use a `Spy` that observes your fake dependency.\n\n    fakeFunction tagger =\n      Command.fake <| tagger \"Success!\"\n\n    test =\n      let\n        spy =\n          Elmer.Spy.observe (\\_ -> fakeFunction)\n            |> Elmer.Spy.andCallThrough\n        updateForTest =\n          MyModule.updateUsing <|\n            Spy.inject (\\_ -> fakeFunction)\n      in\n        Elmer.given testModel MyModule.view updateForTest\n          |> Elmer.Spy.use [ spy ]\n          |> Elmer.Html.target\n              << by [ tag \"input\" ]\n          |> Elmer.Html.Event.input \"some text\"\n          |> Elmer.Html.target\n              << by [ tag \"button\" ]\n          |> Elmer.Html.Event.click\n          |> Elmer.Spy.expect (\\_ -> fakeFunction) (\n            Elmer.Spy.Matchers.wasCalledWith\n              [ Elmer.Spy.Matchers.stringArg \"some text\"\n              ]\n          )\n\nNote: `Elmer.Spy.inject` is necessary because, without wrapping the function to be observed in a\nthunk, there's no opportunity to spy on the function during the test.\n","type":"(() -> a -> b) -> a -> b"},{"name":"observe","comment":" Spy on a function.\n\nUse `Spy.observe` to identify the function you want spy on. \nThen, call `andCallThrough` or `andCallFake` to specify what should be done\nwhen the spied upon function is called.\n\n    let\n      mySpy =\n        observe (\\_ -> MyModule.someFunction)\n          |> andCallThrough\n    in\n      testState\n        |> use [ mySpy ]\n        |> expect (\\_ -> MyModule.someFunction) (\n          wasCalled 0\n        )\n\n","type":"(() -> a -> b) -> Elmer.Spy.SpyReference a b"},{"name":"replaceValue","comment":" Stub a function that simply returns a value.\n\nSuppose you have a function like `Time.now` that takes no arguments and simply\nreturns a value. You can specify the value returned by such a function during your\ntest like so:\n\n    timeNowSpy : Spy\n    timeNowSpy =\n      Task.succeed (Time.millisToPosix 1000)\n        |> Spy.replaceValue (\\_ -> Time.now)\n\nNote: It's not possible to make expectations about spies constructed\nwith `replaceValue`.\n\nNote: An error will result if you attempt to use `replaceValue`\nwith a function that has arguments.\n\n","type":"(() -> a) -> b -> Elmer.Spy.Spy"},{"name":"use","comment":" Install spies for use during the test.\n\nSuppose your component contains a button that,\nwhen clicked, issues a command to get a random number and updates the view. To\nget the random number, in your code you'll need to use `Random.generate` with the\nappropriate `Generator`. To describe this behavior in your test,\nyou could do something like the following:\n\n    let\n      randomSpy =\n        Elmer.Spy.observe (\\_ -> Random.generate)\n        |> andCallFake (\\tagger _ ->\n          tagger 27\n            |> Elmer.Command.fake\n        )\n    in\n      testState\n        |> use [ randomSpy ]\n        |> Elmer.Html.target \n            << by [ id \"get-random\" ]\n        |> Elmer.Html.Event.click\n        |> Elmer.Html.target\n            << by [ id \"current-random\" ]\n        |> Elmer.Html.expect (\n          Elmer.Html.Matchers.element <|\n            Elmer.Html.Matchers.hasText \"27\"\n        )\n\nNote: If you need to replace a spy during the course of a test, you may\ncall `use` again with the new spy. Each time you call `use` *all* spies\nwill be removed. So be sure that each time you call `use` you register all\nthe spies you need.\n","type":"List.List Elmer.Spy.Spy -> Elmer.TestState model msg -> Elmer.TestState model msg"}],"binops":[]},{"name":"Elmer.Spy.Matchers","comment":" Matchers for making expectations about Spies.\n\n# General Expectations\n@docs wasCalled, wasCalledWith\n\n# Expectations About Calls\n@docs Call, calls, hasArgs\n\n# Argument Matchers\n@docs Arg, argThat, anyArg, stringArg, intArg, floatArg, boolArg, typedArg, functionArg\n\n","unions":[],"aliases":[{"name":"Arg","comment":" Represents an expected function argument.\n","args":[],"type":"Elmer.Spy.Arg.Arg"},{"name":"Call","comment":" Represents a particular call to a spy.\n","args":[],"type":"List.List Elmer.Spy.Matchers.Arg"}],"values":[{"name":"anyArg","comment":" Matches any argument.\n","type":"Elmer.Spy.Matchers.Arg"},{"name":"argThat","comment":" Matches an argument whose value satisfies the given matcher.\n\nSuppose you want to expect that the second argument to a function is a record\nwith a specific value for its name attribute. You could do something like this:\n\n    Spy.expect \"my-spy\" (\n      wasCalledWith\n        [ anyArg\n        , argThat <|\n          \\model ->\n            model.name\n              |> Expect.equal \"Awesome Person\"\n        ]\n    )\n\nNote: Bad things will happen if you provide a matcher to `argThat` for a type\nthat is different from that of the argument you are trying to match.\n\n","type":"Elmer.Matcher a -> Elmer.Spy.Matchers.Arg"},{"name":"boolArg","comment":" Matches an argument with the given boolean value.\n","type":"Basics.Bool -> Elmer.Spy.Matchers.Arg"},{"name":"calls","comment":" Make expectations about the calls recorded by this spy.\n\nHere's how you would expect that exactly 2 of the calls had a certain argument.\n\n    Spy.expect \"my-spy\" (\n      calls <| Elmer.exactly 2 <|\n        hasArgs\n        [ stringArg \"some argument\"\n        ]\n    )\n\n","type":"Elmer.Matcher (List.List Elmer.Spy.Matchers.Call) -> Elmer.Matcher Elmer.Spy.Calls"},{"name":"floatArg","comment":" Matches an argument with the given float value.\n","type":"Basics.Float -> Elmer.Spy.Matchers.Arg"},{"name":"functionArg","comment":" Matches an argument that is a function.\n","type":"Elmer.Spy.Matchers.Arg"},{"name":"hasArgs","comment":" Expect that a call has some arguments.\n\nUse `hasArgs` in conjunction with `calls` to make an expectation about the args\nof a specific call.\n\n    Spy.expect \"my-spy\" (\n      calls <| Elmer.atIndex 2 <| hasArgs\n        [ stringArg \"Some String\"\n        , typedArg someTypedValue\n        ]\n    )\n\n","type":"List.List Elmer.Spy.Matchers.Arg -> Elmer.Matcher Elmer.Spy.Matchers.Call"},{"name":"intArg","comment":" Matches an argument with the given integer.\n","type":"Basics.Int -> Elmer.Spy.Matchers.Arg"},{"name":"stringArg","comment":" Matches an argument with the given string.\n","type":"String.String -> Elmer.Spy.Matchers.Arg"},{"name":"typedArg","comment":" Matches an argument with the given typed value.\n\nNote: You may not match what you want if your typed value contains a function reference.\n","type":"a -> Elmer.Spy.Matchers.Arg"},{"name":"wasCalled","comment":" Expect that a spy was called some number of times.\n\nThis is shorthand for:\n\n    Spy.expect \"my-spy\" (calls <| \n      Elmer.hasLength 2\n    )\n\n","type":"Basics.Int -> Elmer.Matcher Elmer.Spy.Calls"},{"name":"wasCalledWith","comment":" Expect that a spy was called at least once with the given arguments.\n\n    Spy.expect \"my-spy\" (\n      wasCalledWith\n        [ stringArg \"Some String\"\n        , typedArg someTypedValue\n        ]\n    )\n\nThis is shorthand for:\n\n    Spy.expect \"my-spy\" (\n      calls <| Elmer.some <| hasArgs\n        [ stringArg \"Some String\"\n        , typedArg someTypedValue\n        ]\n    )\n\n","type":"List.List Elmer.Spy.Matchers.Arg -> Elmer.Matcher Elmer.Spy.Calls"}],"binops":[]},{"name":"Elmer.Subscription","comment":" Functions for dealing with subscriptions during your test.\n\nElmer allows you to manage the effects of subscriptions yourself, so you can\ndescribe the behavior of a component under whatever conditions you need.\n\nTo manage the effects of a subscription, you'll need to do three things.\n\n1. Stub the function in your code that produces the subscription so that\nit returns a fake subscription.\n\n2. Use `with` to register the subscription during your test.\n\n2. Use `send` to send data for that subscription to your component.\n\n3. Enjoy.\n\nNote: Elmer supports `Platform.Sub.batch` and `Platform.Sub.map` so you can use these in your\ncomponent as expected.\n\n# Register Subscriptions\n@docs with\n\n# Create a Fake Subscription\n@docs fake\n\n# Send Data for a Subscription\n@docs send\n\n","unions":[],"aliases":[],"values":[{"name":"fake","comment":" Generate a fake subscription with an identifier and the appropriate tagger.\n\nUse `Elmer.Spy.create` along with `Elmer.Spy.andCallFake` to stub a function\nthat generates a subscription so that it returns a fake instead. Then, once\nthe faked subscription is registered using `with`,\nyou can `send` data on behalf of it subscription during your test.\n\nHere's an example that creates a fake subscription for a port called `receiveMessage`, \nregisters it and sends some data through it.\n\n    let\n      subSpy =\n        Elmer.Spy.create \"fake-port\" (\\_ ->\n          MyPortModule.receiveMessage\n        )\n        |> Elmer.Spy.andCallFake (\\tagger ->\n          Elmer.Subscription.fake \"receiveMessage\" tagger\n        )\n    in\n      Elmer.given defaultModel view update\n        |> Elmer.Spy.use [ subSpy ]\n        |> with (\\() -> subscriptions)\n        |> send \"receiveMessage\" \"Hello!\"\n\n","type":"String.String -> (a -> msg) -> Platform.Sub.Sub msg"},{"name":"send","comment":" Send data on behalf of the identified subscription.\n\nData sent via this function will be tagged accordingly and passed to\nthe component's `update` function for processing.\n","type":"String.String -> a -> Elmer.TestState model msg -> Elmer.TestState model msg"},{"name":"with","comment":" Register fake subscriptions for use during your test.\n\nSuppose your component updates the view with the new time every second. To\nget the time every second, in your code you'll need to create a `subscriptions`\nfunction that returns `Time.every Time.second <tagger>`. To describe this behavior in your test, you\ncould do the following:\n\n    let\n      fakeSub = Elmer.Spy.create \"fake-time\" (\\_ -> Time.every)\n        |> Elmer.Spy.andCallFake (\\interval tagger ->\n          Elmer.Subscription.fake \"everySecond\" tagger\n        )\n    in\n      testState\n        |> Spy.use [ fakeSub ]\n        |> with (\\() -> MyModule.subscriptions)\n        |> send \"everySecond\" (Time.millisToPosix 3000)\n        |> target\n            << by [ id \"current-time\" ]\n        |> Elmer.Html.expect (element <|\n            hasText \"3 seconds\"\n          )\n\n","type":"(() -> model -> Platform.Sub.Sub msg) -> Elmer.TestState model msg -> Elmer.TestState model msg"}],"binops":[]},{"name":"Elmer.Task","comment":" Functions to produce Tasks to use during a test.\n\nTo work with Tasks during a test, you should \n\n1. Stub any functions that generate a Task with `Task.succeed` or `Task.fail`\n2. That's it.\n\nFor example, you could write a test that exercises code using `Browser.Dom.focus` like so:\n\n    focusStub : Spy\n    focusStub =\n      Elmer.Spy.observe (\\_ -> Browser.Dom.focus)\n        |> Elmer.Spy.andCallFake (\\_ -> \n          Task.succeed ()\n        )\n\n    myTest : Test\n    myTest =\n      test \"it does something awesome\" <|\n        \\() ->\n          Elmer.given testModel testView testUpdate\n            |> Spy.use [ focusStub ]\n            |> etc ...\n\nIn this case, the focusStub would allow you to simulate the success of the task produced by\n`Browser.Dom.focus`.\n\nElmer knows how to process Tasks in general (eg, functions like `Task.map`, `Task.andThen`, etc),\nso you only need to stub functions that produce Tasks from modules other than the elm/core `Task` module.\n\n# Special Tasks\n@docs failTest, defer\n\n","unions":[],"aliases":[],"values":[{"name":"defer","comment":" Defer a task for later processing.\n\nYou might want to describe the behavior that occurs after a task\nis sent but before its effect is processed -- for example, you could\nindicate that network activity is occurring while waiting for a request to complete.\n\nWhen a deferred task is processed, any effect associated with that task will *not* be sent\nto the `update` function until `Elmer.resolveDeferred` is called.\n","type":"Task.Task x a -> Task.Task x a"},{"name":"failTest","comment":" Generate a Task that will cause the test to fail with the given message.\n","type":"String.String -> Task.Task x a"}],"binops":[]},{"name":"Elmer.Value","comment":" Inspect Elm values at runtime.\n\nThese functions are most helpful for inspecting the value of an opaque type during a test.\n\n# Decode Elm values\n@docs decode, decoder\n\n# Custom Type Value Decoders\n@docs constructor, firstArg, secondArg, thirdArg\n\n# Data Structure Decoders\n@docs tuple, list, dict\n\n# Debugging\n@docs log\n\n","unions":[],"aliases":[],"values":[{"name":"constructor","comment":" Decode the constructor of a Custom Type value.\n\nSuppose there's a custom type like so:\n\n    type SuperType\n      = FunType String\n      | AwesomeType Int\n\nThen, if `superTypeValue` is a `FunType \"Bowling\"`, you can decode its constructor like so.\n\n    Elmer.Value.decode constructor superTypeValue\n\nThis will result in: `Ok \"FunType\"`\n\nIt can be useful to combine this function with `Json.andThen` to decide which decoder to \nprovide for a value:\n\n    constructor\n      |> Json.andThen (\\ctor ->\n        case ctor of\n          \"FunType\" -> funTypeDecoder\n          \"AwesomeType\" -> awesomeTypeDecoder\n          _ -> Json.fail \"Not a SuperType\"\n      )\n\n","type":"Json.Decode.Decoder String.String"},{"name":"decode","comment":" Decode an Elm value.\n\nSince Elm values are JS objects under the hood, you can use any JSON decoder here.\nHowever, you'll probably want to take advantage of the special decoders provided in this module, as\nthey encapsulate some of the details about how Elm values are represented in JS. \n\nUse `Elmer.Value.log` to help you discern what you might want to decode.\n","type":"Json.Decode.Decoder a -> v -> Result.Result Json.Decode.Error b"},{"name":"decoder","comment":" Decode an arbitrary value.\n\nSuppose there's an opaque type that hides a function:\n\n    type HiddenFunction =\n      HiddenFunction (String -> Int)\n\nYou could decode the function like so:\n\n    Elmer.Value.firstArg decoder\n\nBy using this decoder on a `HiddenFunction` value, you can gain access\nto and use the function just like you'd expect.\n\n","type":"Json.Decode.Decoder a"},{"name":"dict","comment":" Decode an Elm dict.\n\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder (Dict.Dict String.String a)"},{"name":"firstArg","comment":" Decode the first argument of a Custom Type value.\n\nSuppose there's a custom type like so:\n\n    type SuperType\n      = FunType String\n      | AwesomeType Int\n\nThen, if `superTypeValue` is a `FunType \"Bowling\"`, you can decode its first argument like so.\n\n    Elmer.Value.decode (firstArg Json.string) superTypeValue\n\nThis will result in: `Ok \"Bowling\"`.\n\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder v"},{"name":"list","comment":" Decode an Elm list.\n\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder (List.List a)"},{"name":"log","comment":" Log an Elm Value.\n\nThis function works like `Debug.log` but prints more details\nabout how the value is represented in JS.\n\n","type":"String.String -> v -> v"},{"name":"secondArg","comment":" Decode the second argument of a Custom Type value.\n\nSuppose there's a custom type like so:\n\n    type SuperType\n      = CoolType String Int SomeRecord\n\nThen, if `superTypeValue` is a `CoolType \"Bowling\" 28 myRecord`, you can decode its second argument like so.\n\n    Elmer.Value.decode (secondArg Json.int) superTypeValue\n\nThis will result in: `Ok 28`.\n\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder v"},{"name":"thirdArg","comment":" Decode the third argument of a Custom Type value.\n\nSuppose there's a custom type like so:\n\n    type SuperType\n      = CoolType String Int SomeRecord\n\nThen, if `superTypeValue` is a `CoolType \"Bowling\" 28 myRecord`, you can decode its third argument like so.\n\n    Elmer.Value.decode (thirdArg someRecordDecoder) superTypeValue\n\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder v"},{"name":"tuple","comment":" Decode an Elm tuple.\n\nMaybe there's an opaque type that hides a tuple:\n\n    type HiddenTuple =\n      HiddenTuple (String, Int)\n\nHere's a decoder that allows you to inspect the tuple in a `HiddenTuple` value:\n\n    Elmer.Value.firstArg <| \n      tuple Json.string Json.int\n\n","type":"Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder ( a, b )"}],"binops":[]}]